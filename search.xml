<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ktor 学习与实践文档</title>
      <link href="/2025/09/28/Ktor%20%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5%E6%96%87%E6%A1%A3/"/>
      <url>/2025/09/28/Ktor%20%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-Multiplatform-KMP-Ktor-学习与实践文档"><a href="#Kotlin-Multiplatform-KMP-Ktor-学习与实践文档" class="headerlink" title="Kotlin Multiplatform (KMP) + Ktor 学习与实践文档"></a>Kotlin Multiplatform (KMP) + Ktor 学习与实践文档</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Kotlin Multiplatform (KMP) 是 JetBrains 提供的跨平台开发方案，核心思想是<strong>逻辑层代码共享，UI 层保持原生</strong>。在 KMP 中，网络层通常使用 <strong>Ktor</strong>，这是一个由 JetBrains 开发的异步网络框架，天然支持多平台（Android、iOS、Desktop、Web）。</p><p>KMP + Ktor 的组合，能让我们用一套代码实现跨平台的网络请求逻辑。</p><hr><h2 id="二、Ktor-特性"><a href="#二、Ktor-特性" class="headerlink" title="二、Ktor 特性"></a>二、Ktor 特性</h2><ul><li><strong>跨平台支持</strong>：Android 使用 OkHttp，iOS 使用 NSURLSession，桌面和 Web 也有各自实现。</li><li><strong>异步非阻塞</strong>：基于协程，性能高。</li><li><strong>模块化插件</strong>：支持 JSON 序列化、认证、日志、WebSocket 等。</li><li><strong>客户端与服务端统一</strong>：既能写客户端 SDK，也能写后端服务。</li></ul><hr><h2 id="三、项目结构"><a href="#三、项目结构" class="headerlink" title="三、项目结构"></a>三、项目结构</h2><p>KMP 项目典型结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared/</span><br><span class="line">  ├── commonMain/       # 共享逻辑 (Ktor 请求、Repository、UseCase)</span><br><span class="line">  ├── androidMain/      # Android 平台特定实现</span><br><span class="line">  ├── iosMain/          # iOS 平台特定实现</span><br><span class="line">  └── ...</span><br></pre></td></tr></table></figure><p>在 <code>commonMain</code> 中编写网络请求逻辑，Android 与 iOS 会自动调用对应平台实现。</p><hr><h2 id="四、依赖配置"><a href="#四、依赖配置" class="headerlink" title="四、依赖配置"></a>四、依赖配置</h2><p>在 <code>shared/build.gradle.kts</code> 中添加：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">kotlin &#123;</span><br><span class="line">    android()</span><br><span class="line">    iosX64()</span><br><span class="line">    iosArm64()</span><br><span class="line">    iosSimulatorArm64()</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        <span class="keyword">val</span> commonMain <span class="keyword">by</span> getting &#123;</span><br><span class="line">            dependencies &#123;</span><br><span class="line">                implementation(<span class="string">&quot;io.ktor:ktor-client-core:3.0.0&quot;</span>)</span><br><span class="line">                implementation(<span class="string">&quot;io.ktor:ktor-client-content-negotiation:3.0.0&quot;</span>)</span><br><span class="line">                implementation(<span class="string">&quot;io.ktor:ktor-serialization-kotlinx-json:3.0.0&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> androidMain <span class="keyword">by</span> getting &#123;</span><br><span class="line">            dependencies &#123;</span><br><span class="line">                implementation(<span class="string">&quot;io.ktor:ktor-client-okhttp:3.0.0&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> iosMain <span class="keyword">by</span> creating &#123;</span><br><span class="line">            dependencies &#123;</span><br><span class="line">                implementation(<span class="string">&quot;io.ktor:ktor-client-darwin:3.0.0&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="五、代码示例"><a href="#五、代码示例" class="headerlink" title="五、代码示例"></a>五、代码示例</h2><h3 id="1-数据模型"><a href="#1-数据模型" class="headerlink" title="1. 数据模型"></a>1. 数据模型</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.serialization.Serializable</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure><h3 id="2-HttpClient-初始化"><a href="#2-HttpClient-初始化" class="headerlink" title="2. HttpClient 初始化"></a>2. HttpClient 初始化</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.ktor.client.*</span><br><span class="line"><span class="keyword">import</span> io.ktor.client.plugins.contentnegotiation.*</span><br><span class="line"><span class="keyword">import</span> io.ktor.serialization.kotlinx.json.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> httpClient = HttpClient &#123;</span><br><span class="line">    install(ContentNegotiation) &#123;</span><br><span class="line">        json()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-封装请求逻辑"><a href="#3-封装请求逻辑" class="headerlink" title="3. 封装请求逻辑"></a>3. 封装请求逻辑</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.ktor.client.call.*</span><br><span class="line"><span class="keyword">import</span> io.ktor.client.request.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchUser</span><span class="params">(userId: <span class="type">Int</span>)</span></span>: User &#123;</span><br><span class="line">    <span class="keyword">return</span> httpClient.<span class="keyword">get</span>(<span class="string">&quot;https://api.example.com/users/<span class="variable">$userId</span>&quot;</span>).body()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Repository-层"><a href="#4-Repository-层" class="headerlink" title="4. Repository 层"></a>4. Repository 层</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId: <span class="type">Int</span>)</span></span>: User = fetchUser(userId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-ViewModel-层-使用协程"><a href="#5-ViewModel-层-使用协程" class="headerlink" title="5. ViewModel 层 (使用协程)"></a>5. ViewModel 层 (使用协程)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.MutableStateFlow</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.StateFlow</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserViewModel</span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: UserRepository) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _user = MutableStateFlow&lt;User?&gt;(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">val</span> user: StateFlow&lt;User?&gt; = _user</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadUser</span><span class="params">(id: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        _user.value = repository.getUser(id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="六、平台调用"><a href="#六、平台调用" class="headerlink" title="六、平台调用"></a>六、平台调用</h2><h3 id="Android-Jetpack-Compose"><a href="#Android-Jetpack-Compose" class="headerlink" title="Android (Jetpack Compose)"></a>Android (Jetpack Compose)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel = UserViewModel(UserRepository())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            <span class="keyword">val</span> user <span class="keyword">by</span> viewModel.user.collectAsState()</span><br><span class="line">            LaunchedEffect(<span class="built_in">Unit</span>) &#123; viewModel.loadUser(<span class="number">123</span>) &#125;</span><br><span class="line"></span><br><span class="line">            Text(text = user?.name ?: <span class="string">&quot;Loading...&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iOS-Swift"><a href="#iOS-Swift" class="headerlink" title="iOS (Swift)"></a>iOS (Swift)</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> shared</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">            .task &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> user <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">UserRepository</span>().getUser(userId: <span class="number">123</span>)</span><br><span class="line">                    <span class="built_in">print</span>(user.name)</span><br><span class="line">                &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="七、进阶用法"><a href="#七、进阶用法" class="headerlink" title="七、进阶用法"></a>七、进阶用法</h2><ul><li><strong>拦截器</strong>：日志、鉴权 Header 注入</li><li><strong>WebSocket</strong>：即时通讯、推送</li><li><strong>多环境配置</strong>：BaseUrl 根据平台&#x2F;构建类型切换</li><li><strong>与 SQLDelight 集成</strong>：实现离线缓存（Network + Local）</li></ul><hr><h2 id="八、架构推荐"><a href="#八、架构推荐" class="headerlink" title="八、架构推荐"></a>八、架构推荐</h2><p>典型的 KMP + Ktor 数据层架构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">View (Compose / SwiftUI)</span><br><span class="line">       ↓</span><br><span class="line">ViewModel (StateFlow + 协程)</span><br><span class="line">       ↓</span><br><span class="line">Repository (调用 API + 数据库)</span><br><span class="line">       ↓</span><br><span class="line">Ktor HttpClient (跨平台)</span><br></pre></td></tr></table></figure><hr><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><ul><li><strong>KMP 提供跨平台逻辑共享能力</strong></li><li><strong>Ktor 作为跨平台网络框架</strong>，是数据层的核心实现</li><li>Android&#x2F;iOS 都能直接调用，无需写两套请求逻辑</li><li>推荐搭配：<code>Ktor + kotlinx.serialization + SQLDelight + Koin</code>，形成完整的数据层解决方案</li></ul>]]></content>
      
      
      <categories>
          
          <category> KMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter - AutoRoute</title>
      <link href="/2025/09/21/Flutter%20-%20AutoRoute/"/>
      <url>/2025/09/21/Flutter%20-%20AutoRoute/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h4 id="What-is-AutoRoute"><a href="#What-is-AutoRoute" class="headerlink" title="What is AutoRoute?"></a>What is AutoRoute?</h4><p>它是一个 Flutter 导航包，支持强类型参数传递、轻松的深度链接，并使用代码生成来简化路由设置。也就是说，它只需要极少量的代码即可生成应用内部导航所需的一切。</p><h4 id="Why-AutoRoute"><a href="#Why-AutoRoute" class="headerlink" title="Why AutoRoute?"></a>Why AutoRoute?</h4><p>如果您的应用需要深层链接、受保护的路由，或者只是需要简洁的路由设置，那么您将需要使用命名&#x2F;生成路由，并且最终需要为中介参数类编写大量样板代码，检查所需参数 <strong>、</strong> 提取参数等等。AutoRoute 可以为您完成所有这些工作，甚至更多。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>将以下依赖项添加到您的 <code>pubspec.yaml</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line"> auto_route: [latest-version]</span><br><span class="line"></span><br><span class="line">dev_dependencies:</span><br><span class="line"> auto_route_generator: [latest-version]</span><br><span class="line"> build_runner:</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add auto_route dev:auto_route_generator dev:build_runner</span><br></pre></td></tr></table></figure><h2 id="LeanBuilder-支持"><a href="#LeanBuilder-支持" class="headerlink" title="LeanBuilder 支持"></a>LeanBuilder 支持</h2><p>auto_route_generator：（10.2.3+）现在支持 <a href="https://pub.dev/packages/lean_builder">LeanBuilder</a> 实现超快速增量构建。</p><p>要使用 lean_builder 而不是 build_runner，只需将其添加到您的 dev_dependencies 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dev_dependencies:</span><br><span class="line">  auto_route_generator: &lt;latest-version&gt;</span><br><span class="line">  lean_builder: &lt;latest-version&gt;</span><br></pre></td></tr></table></figure><p>然后使用以下命令运行构建器：进行一次性构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dart run lean_builder build</span><br></pre></td></tr></table></figure><p>用于查看文件并根据更改进行重建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dart run lean_builder watch</span><br></pre></td></tr></table></figure><p>要禁用 <code>auto_route_generator</code> 使用 build_runner，您可以将以下内容添加到 <code>build.yaml</code> 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">targets:</span><br><span class="line">  $default:</span><br><span class="line">    builders:</span><br><span class="line">      auto_route_generator:auto_route_generator:</span><br><span class="line">        enabled: false</span><br><span class="line">      auto_route_generator:auto_router_generator:</span><br><span class="line">        enabled: false</span><br></pre></td></tr></table></figure><h1 id="设置和使用"><a href="#设置和使用" class="headerlink" title="设置和使用"></a>设置和使用</h1><ol><li>创建一个路由器类并用 <code>@AutoRouterConfig</code> 注释它，然后从 auto_route 包中扩展“RootStackRouter”</li><li>重写路由获取并开始添加路由</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@AutoRouterConfig()</span><br><span class="line">class AppRouter extends RootStackRouter &#123;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  List&lt;AutoRoute&gt; get routes =&gt; [</span><br><span class="line">    /// routes go here</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Using-part-builder"><a href="#Using-part-builder" class="headerlink" title="Using part builder"></a>Using part builder</h3><p>要生成部分文件，只需向 <code>AppRouter</code> 添加 <code>part</code> 指令。</p><p><strong>注意：</strong> <code>deferredLoading</code> 功能不适用于部分文件设置。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HarmonyOS-两种PreferencesUtil实现方式</title>
      <link href="/2025/01/20/HarmonyOS-%E4%B8%A4%E7%A7%8DPreferencesUtil%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/01/20/HarmonyOS-%E4%B8%A4%E7%A7%8DPreferencesUtil%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">const TAG = &quot;PreferencesUtil&quot;</span><br><span class="line">const PREFERENCES_NAME = &#x27;graduation_preferences&#x27;</span><br><span class="line">type ValueType = number | string | boolean | Array&lt;number&gt; | Array&lt;string&gt; | Array&lt;boolean&gt; | Uint8Array | object</span><br><span class="line">  | bigint ;</span><br><span class="line"></span><br><span class="line">export class PreferencesUtil &#123;</span><br><span class="line">  private static preferences: dataPreferences.Preferences</span><br><span class="line">  private static preferencesAsync: Promise&lt;dataPreferences.Preferences&gt;</span><br><span class="line"></span><br><span class="line">  private constructor() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static init(context: common.UIAbilityContext, name: string = PREFERENCES_NAME) &#123;</span><br><span class="line">    if (PreferencesUtil.preferences) return</span><br><span class="line">    PreferencesUtil.preferences = dataPreferences.getPreferencesSync(context, &#123; name &#125;)</span><br><span class="line">    PreferencesUtil.preferencesAsync = dataPreferences.getPreferences(context, name).then(r =&gt; &#123;</span><br><span class="line">      return r</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static async getPreferencesAsync(): Promise&lt;dataPreferences.Preferences&gt; &#123;</span><br><span class="line">    if (!(await PreferencesUtil.preferencesAsync)) &#123;</span><br><span class="line">      throw new Error(&#x27;调用init()方法完成初始化&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return PreferencesUtil.preferencesAsync</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private static getPreferences(): dataPreferences.Preferences &#123;</span><br><span class="line">    if (!PreferencesUtil.preferences) &#123;</span><br><span class="line">      throw new Error(&#x27;调用init()方法完成初始化&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return PreferencesUtil.preferences</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  static async getAsync&lt;T extends ValueType&gt;(key: string, def?: ValueType): Promise&lt;T&gt; &#123;</span><br><span class="line">    const p = await PreferencesUtil.getPreferencesAsync()</span><br><span class="line">    return new Promise&lt;T&gt;((resolve, reject) =&gt; &#123;</span><br><span class="line">      p.get(key, def, (err: BusinessError, data: dataPreferences.ValueType) =&gt; &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">          console.error(TAG,err)</span><br><span class="line">          reject(def)</span><br><span class="line">        &#125;</span><br><span class="line">        if (data) &#123;</span><br><span class="line">          resolve(data as T)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  static get&lt;T extends ValueType&gt;(key: string, def?: ValueType): T &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return PreferencesUtil.getPreferences().getSync(key, def) as T</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      // Logger.et(TAG, e)</span><br><span class="line">      console.error(TAG,err)</span><br><span class="line">    &#125;</span><br><span class="line">    return def as T</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  static async getAllAsync(): Promise&lt;Object&gt; &#123;</span><br><span class="line">    let preferences = await PreferencesUtil.getPreferencesAsync()</span><br><span class="line">    return preferences.getAll()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getAll(): Object | null &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return PreferencesUtil.getPreferences().getAllSync()</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(TAG,err)</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static async putAsync(key: string, value: ValueType): Promise&lt;void&gt; &#123;</span><br><span class="line">    const r = await PreferencesUtil.getPreferencesAsync().then(async (p) =&gt; &#123;</span><br><span class="line">      await p.put(key, value)</span><br><span class="line">      await p.flush();</span><br><span class="line">    &#125;).catch((err: Error) =&gt; &#123;</span><br><span class="line">      console.error(TAG,err)</span><br><span class="line">    &#125;)</span><br><span class="line">    return r</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  static put(key: string, value: ValueType): void &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      PreferencesUtil.getPreferences().putSync(key, value)</span><br><span class="line">      PreferencesUtil.getPreferences().flush()</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(TAG,err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static hasKey(key: string): boolean &#123;</span><br><span class="line">    let has: boolean = false</span><br><span class="line">    try &#123;</span><br><span class="line">      has = PreferencesUtil.getPreferences().hasSync(key)</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(TAG,err)</span><br><span class="line">    &#125;</span><br><span class="line">    return has</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static async deleteAsync(key: string): Promise&lt;void&gt; &#123;</span><br><span class="line">    return (await PreferencesUtil.getPreferencesAsync()).delete(key)</span><br><span class="line">      .catch((err: Error) =&gt; &#123;</span><br><span class="line">        console.error(TAG,err)</span><br><span class="line">      &#125;)</span><br><span class="line">      .finally(async () =&gt; &#123;</span><br><span class="line">        (await PreferencesUtil.getPreferencesAsync()).flush()</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static delete(key: string): void &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      PreferencesUtil.getPreferences().deleteSync(key)</span><br><span class="line">      PreferencesUtil.getPreferences().flush()</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(TAG,err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static async clearAsync(): Promise&lt;void&gt; &#123;</span><br><span class="line">    return (await PreferencesUtil.getPreferencesAsync()).clear()</span><br><span class="line">      .catch((err: Error) =&gt; &#123;</span><br><span class="line">        console.error(TAG,err)</span><br><span class="line">      &#125;)</span><br><span class="line">      .finally(async () =&gt; &#123;</span><br><span class="line">        (await PreferencesUtil.getPreferencesAsync()).flush()</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static clear(): void &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      PreferencesUtil.preferences.clearSync()</span><br><span class="line">      PreferencesUtil.preferences.flush()</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(TAG,err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">const TAG = &#x27;PreferencesUtil&#x27;;</span><br><span class="line">const MY_STORE = &#x27;myStore&#x27;;</span><br><span class="line">const FORM_ID = &#x27;formIds&#x27;;</span><br><span class="line"></span><br><span class="line">export class PreferencesUtil &#123;</span><br><span class="line">  private static preferencesUtil: PreferencesUtil;</span><br><span class="line"></span><br><span class="line">  public static getInstance(): PreferencesUtil &#123;</span><br><span class="line">    if (!PreferencesUtil.preferencesUtil) &#123;</span><br><span class="line">      PreferencesUtil.preferencesUtil = new PreferencesUtil();</span><br><span class="line">    &#125;</span><br><span class="line">    return PreferencesUtil.preferencesUtil;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPreferences(context: Context): Promise&lt;preferences.Preferences&gt; &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      preferences.getPreferences(context, MY_STORE, (err, pref: preferences.Preferences) =&gt; &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">          Logger.error(TAG, `Failed to get preferences. Code:$&#123;err.code&#125;,message:$&#123;err.message&#125;`);</span><br><span class="line">          reject(err);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(pref);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preferencesFlush(preferences: preferences.Preferences) &#123;</span><br><span class="line">    preferences.flush((err) =&gt; &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        Logger.error(TAG, `Failed to flush. Code:$&#123;err.code&#125;, message:$&#123;err.message&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preferencesPut(preferences: preferences.Preferences, formIds: Array&lt;string&gt;): Promise&lt;boolean&gt; &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        preferences.put(FORM_ID, formIds, (err) =&gt; &#123;</span><br><span class="line">          if (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">            Logger.error(TAG, `Failed to put data. Code:$&#123;err.code&#125;, message:$&#123;err.message&#125;`);</span><br><span class="line">            return;</span><br><span class="line">          &#125;</span><br><span class="line">          Logger.info(TAG, `preferencesPut succeed,formIds: $&#123;JSON.stringify(formIds)&#125;`);</span><br><span class="line">          resolve(true);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; catch (error) &#123;</span><br><span class="line">        Logger.error(TAG, `Failed to put data. Code: $&#123;(error as BusinessError).code&#125;,</span><br><span class="line">        message:$&#123;(error as BusinessError).message&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async preferencesHas(preferences: preferences.Preferences): Promise&lt;boolean&gt; &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      preferences.has(FORM_ID, (err, value) =&gt; &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          Logger.error(TAG, `WANG to check the key &#x27;formIds&#x27;. Code:$&#123;err.code&#125;, message:$&#123;err.message&#125;`);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removePreferencesFromCache(context: Context): void &#123;</span><br><span class="line">    preferences.removePreferencesFromCache(context, MY_STORE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getFormIds(context: Context): Promise&lt;Array&lt;string&gt;&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      let preferences = await this.getPreferences(context);</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        if (preferences === null) &#123;</span><br><span class="line">          Logger.error(TAG, `preferences is null`);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        preferences.get(FORM_ID, [&#x27;&#x27;], (err: BusinessError, value: preferences.ValueType) =&gt; &#123;</span><br><span class="line">          if (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">            Logger.error(TAG, `Failed to get value of &#x27;formIds&#x27;. Code:$&#123;err.code&#125;, message:$&#123;err.message&#125;`);</span><br><span class="line">            return;</span><br><span class="line">          &#125;</span><br><span class="line">          resolve(value as Array&lt;string&gt;);</span><br><span class="line">          Logger.info(TAG, `Succeeded in getting value of &#x27;formIds&#x27;. val: $&#123;value&#125;.`);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      Logger.error(TAG, `WANG Failed to get value of &#x27;formIds&#x27;. Code:$&#123;(error as BusinessError).code&#125;,</span><br><span class="line">       message:$&#123;(error as BusinessError).message&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async addFormId(context: Context, formId: string) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      let preferences = await this.getPreferences(context);</span><br><span class="line">      if (preferences === null) &#123;</span><br><span class="line">        Logger.error(TAG, `preferences is null`);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (await this.preferencesHas(preferences)) &#123;</span><br><span class="line">        let formIds = await this.getFormIds(context);</span><br><span class="line">        if (formIds.indexOf(formId) === -1) &#123;</span><br><span class="line">          formIds.push(formId);</span><br><span class="line">          if (!await this.preferencesPut(preferences, formIds)) &#123;</span><br><span class="line">            return;</span><br><span class="line">          &#125;</span><br><span class="line">          this.preferencesFlush(preferences);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (!await this.preferencesPut(preferences, [formId])) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.preferencesFlush(preferences);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      Logger.error(TAG, `Failed to check the key &#x27;formIds&#x27;. Code:$&#123;(error as BusinessError).code&#125;,</span><br><span class="line">       message:$&#123;(error as BusinessError).message&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async removeFormId(context: Context, formId: string) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      let preferences = await this.getPreferences(context);</span><br><span class="line">      if (preferences === null) &#123;</span><br><span class="line">        Logger.error(TAG, `preferences is null`);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (await this.preferencesHas(preferences)) &#123;</span><br><span class="line">        let formIds = await this.getFormIds(context);</span><br><span class="line">        let index = formIds.indexOf(formId);</span><br><span class="line">        if (index !== -1) &#123;</span><br><span class="line">          formIds.splice(index, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!await this.preferencesPut(preferences, formIds)) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.preferencesFlush(preferences);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      Logger.error(TAG, `WANG Failed to get preferences. Code:$&#123;(error as BusinessError).code&#125;,</span><br><span class="line">      message:$&#123;(error as BusinessError).message&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HarmonyOS-@ohos/axios网络请求</title>
      <link href="/2024/12/01/HarmonyOS-@ohos/axios%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
      <url>/2024/12/01/HarmonyOS-@ohos/axios%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>由于HarmonyOS官方提供的网络请求比较复杂，不太适用于项目管理，需要进行网络框架的封装。</p><p>主要使用较广的第三方网络请求框架有 <strong>@ohos&#x2F;axios</strong> 和 <strong>@ohos&#x2F;retrofit</strong></p><p><strong>@ohos&#x2F;axios</strong> 主要偏向前端，和前端的axios很相似，对于前端开发者能够很快上手</p><p><strong>@ohos&#x2F;retrofit</strong> 主要偏向Android和其retrofit框架相似，主要通过注解的方式进行网络请求</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p><strong>ohos&#x2F;axios</strong> 的安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ohpm install @ohos/axios</span><br></pre></td></tr></table></figure><p><strong>ohos&#x2F;retrofit</strong> 的安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ohpm install @ohos/retrofit</span><br></pre></td></tr></table></figure><p>这里主要介绍 <strong>@ohos&#x2F;axios</strong> 的封装使用</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ohos.permission.INTERNET</span><br></pre></td></tr></table></figure><h3 id="封装使用示例"><a href="#封装使用示例" class="headerlink" title="封装使用示例"></a>封装使用示例</h3><p>首先我们需要创建一个request.arkts的文件，进行对base_url的管理。如果我们需要对业务逻辑处理的话，需要先对code,msg,data进行封装处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface BaseResponse&lt;T&gt;&#123;</span><br><span class="line">  code?:string,</span><br><span class="line">  msg?:string,</span><br><span class="line">  data:T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建axios实例对象"><a href="#创建axios实例对象" class="headerlink" title="创建axios实例对象"></a>创建axios实例对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const instance = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;http://10.159.36.81:5600/api&#x27;,</span><br><span class="line">  timeout: 30000,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="添加请求拦截器"><a href="#添加请求拦截器" class="headerlink" title="添加请求拦截器"></a>添加请求拦截器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">instance.interceptors.request.use((config:InternalAxiosRequestConfig)=&gt;&#123;</span><br><span class="line">  const token = PreferencesUtil.get(&#x27;token&#x27;) as string</span><br><span class="line">  if (token) &#123;</span><br><span class="line">    config.headers[&#x27;Authorization&#x27;] = &#x27;Bearer &#x27; + token;</span><br><span class="line">  &#125;</span><br><span class="line">  return config</span><br><span class="line">&#125;, (error:AxiosError) =&gt; &#123;</span><br><span class="line">  // 对请求错误做些什么</span><br><span class="line">  console.error(&#x27;request error:&#x27; + error);</span><br><span class="line">  return Promise.reject(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="添加响应拦截器"><a href="#添加响应拦截器" class="headerlink" title="添加响应拦截器"></a>添加响应拦截器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">instance.interceptors.response.use((response: AxiosResponse) =&gt; &#123;</span><br><span class="line">  return response.data</span><br><span class="line">&#125;, (error: AxiosError) =&gt; &#123;</span><br><span class="line">  if (error.response) &#123;</span><br><span class="line">    // 处理已知错误</span><br><span class="line">    console.error(&#x27;Response Error:&#x27;, error.response.data)</span><br><span class="line">  &#125; else if (error.request) &#123;</span><br><span class="line">    // 处理请求发送失败</span><br><span class="line">    console.error(&#x27;Request Error:&#x27;, error.request)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 处理其他错误</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error.message)</span><br><span class="line">  &#125;</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="进行导出以便调用"><a href="#进行导出以便调用" class="headerlink" title="进行导出以便调用"></a>进行导出以便调用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default &lt;T&gt; (config:AxiosRequestConfig):Promise&lt;BaseResponse&lt;T&gt;&gt;=&gt;&#123;</span><br><span class="line">  return instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="网络请求示例"><a href="#网络请求示例" class="headerlink" title="网络请求示例"></a>网络请求示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface LoginRequest&#123;</span><br><span class="line">  email:string,</span><br><span class="line">  password:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface LoginResponse&#123;</span><br><span class="line">  userid:string,</span><br><span class="line">  username:string,</span><br><span class="line">  email:string,</span><br><span class="line">  avatar:string,</span><br><span class="line">  sex?:string,</span><br><span class="line">  token:string</span><br><span class="line">&#125;</span><br><span class="line">export function login&lt;T&gt;(data:LoginRequest)&#123;</span><br><span class="line">  return request&lt;T&gt;(&#123;</span><br><span class="line">    url:&#x27;/users/login&#x27;,</span><br><span class="line">    method:&#x27;POST&#x27;,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是在登录界面进行使用的demo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private async  handleLogin() &#123;</span><br><span class="line">   this.isLoading = true;</span><br><span class="line">   try &#123;</span><br><span class="line">     const result = await login&lt;LoginResponse&gt;(&#123;</span><br><span class="line">       email:this.email,</span><br><span class="line">       password:this.password</span><br><span class="line">     &#125;)</span><br><span class="line">     console.log(&#x27;Received login response:&#x27;, JSON.stringify(result));</span><br><span class="line">     if (result.code === &#x27;200&#x27;) &#123;</span><br><span class="line">       // TokenUtil.setToken(result.data.token)</span><br><span class="line">       PreferencesUtil.put(&#x27;token&#x27;, result.data.token)</span><br><span class="line">       router.replaceUrl(&#123;</span><br><span class="line">         url:&#x27;pages/MainPage&#x27;</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;else &#123;</span><br><span class="line">       promptAction.showToast(&#123;</span><br><span class="line">         message: result.msg</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;catch (error)&#123;</span><br><span class="line">     console.error(&#x27;登录请求失败:&#x27;, error);</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     this.isLoading = false</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="完整的代码场景参考"><a href="#完整的代码场景参考" class="headerlink" title="完整的代码场景参考"></a>完整的代码场景参考</h4><p><a href="https://github.com/MartinLiuMingZhi/Graduation-HarmonyOS/tree/main/entry/src/main/ets/request">Graduation-HarmonyOS&#x2F;entry&#x2F;src&#x2F;main&#x2F;ets&#x2F;request at main · MartinLiuMingZhi&#x2F;Graduation-HarmonyOS</a></p>]]></content>
      
      
      <categories>
          
          <category> HarmonyOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HarmonyOS </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava 面试题</title>
      <link href="/2024/09/09/RxJava%20%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/09/09/RxJava%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-RxJava基本概念和原理是什么？"><a href="#1-RxJava基本概念和原理是什么？" class="headerlink" title="1.RxJava基本概念和原理是什么？"></a>1.RxJava基本概念和原理是什么？</h3><p><strong>答案：</strong><br>RxJava 是一个用于响应式编程的库，通过 Observable（可观察对象）来发射数据流，并通过 Observer（观察者）来消费数据流。它使用操作符（Operators）来对数据流进行变换、过滤、合并等操作，允许我们以声明式的方式编写异步代码。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高新兴实习第三周</title>
      <link href="/2024/08/11/%E9%AB%98%E6%96%B0%E5%85%B4%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%91%A8/"/>
      <url>/2024/08/11/%E9%AB%98%E6%96%B0%E5%85%B4%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%91%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高新兴实习第二周</title>
      <link href="/2024/08/11/%E9%AB%98%E6%96%B0%E5%85%B4%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%91%A8/"/>
      <url>/2024/08/11/%E9%AB%98%E6%96%B0%E5%85%B4%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="实习第6天-2024-7-29"><a href="#实习第6天-2024-7-29" class="headerlink" title="实习第6天 2024-7-29"></a>实习第6天 2024-7-29</h2><p>帮助部门进行测试包转发，查看学习大疆SDK开发者文档。</p><h2 id="实习第7天-2024-7-30"><a href="#实习第7天-2024-7-30" class="headerlink" title="实习第7天 2024-7-30"></a>实习第7天 2024-7-30</h2><p>基本大致了解完大疆开发者文档，熟悉大疆SDK接口的调用流程。学习EventBus框架，熟悉订阅者模式</p><h2 id="实习第8天-2024-7-31"><a href="#实习第8天-2024-7-31" class="headerlink" title="实习第8天 2024-7-31"></a>实习第8天 2024-7-31</h2><p>无人机的主要功能大致已经有所了解</p><h2 id="实习第9天-2024-8-1"><a href="#实习第9天-2024-8-1" class="headerlink" title="实习第9天 2024-8-1"></a>实习第9天 2024-8-1</h2><p>查看一些Android开发文档，编写一些demo进行练习；修改时间戳代码，并进行打包。</p><h2 id="实习第9天-2024-8-2"><a href="#实习第9天-2024-8-2" class="headerlink" title="实习第9天 2024-8-2"></a>实习第9天 2024-8-2</h2><p>重新调试更改配置，进行打包APK测试和交付。修改登录时未点击保存产生的闪退，进行无人机测试修改。</p>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高新兴 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-EventBus</title>
      <link href="/2024/07/29/Android-EventBus/"/>
      <url>/2024/07/29/Android-EventBus/</url>
      
        <content type="html"><![CDATA[<p><strong>EventBus线程模式</strong></p><p>EventBus支持订阅者和发布者在不同的线程中调用。可以使用线程模式来指定调用订阅者方法的线程。EventBus支持5种线程模式。</p><ul><li><strong>ThreadMode.POSRING</strong></li><li><strong>ThreadMode.MAIN</strong></li><li><strong>ThreadMode.MAIN_ORDERED</strong></li><li><strong>ThreadMode.BACKGROUND</strong></li><li><strong>ThreadMode.ASYNC</strong></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RxJava-函数响应式编程</title>
      <link href="/2024/07/25/RxJava-%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/07/25/RxJava-%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="函数响应式编程概述"><a href="#函数响应式编程概述" class="headerlink" title="函数响应式编程概述"></a>函数响应式编程概述</h3><p>函数式编程是面向数学的抽象，把计算描述为一种表达式求值，函数可以在任何地方定义，并且可以对函数进行组合。</p><p>响应式编程是一种面向数据流和变化传播的编程范式，数据更新是相关联的。把函数式编程里的一套思路和响应式编程组合起来就是函数响应式编程。</p><p>函数响应式编程可以简化项目，特别是处理嵌套回调的异步事件、复杂的列表过滤和变化或者时间相关问题。在Android开发中主要的两大框架：RxJava和Agera。</p><p>RxJava:</p><ul><li>异步处理库</li><li>可拓展的观察者模式</li></ul><p>RxJava的异步操作是通过扩展的观察者模式来实现的。RxJava有四个角色<strong>Observable</strong>、<strong>Observer</strong>、<strong>Subscriber</strong>、<strong>Subject</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高新兴实习第一周</title>
      <link href="/2024/07/21/%E9%AB%98%E6%96%B0%E5%85%B4%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
      <url>/2024/07/21/%E9%AB%98%E6%96%B0%E5%85%B4%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="实习第一天-2024-7-21"><a href="#实习第一天-2024-7-21" class="headerlink" title="实习第一天 2024-7-21"></a>实习第一天 2024-7-21</h2><p>今天进行了入职报道，去到了人力资源部递交了一些入职材料，然后在会议室里签署了个人资料，实习协议书，保密协议，以及薪资条款。之后HR给我们讲解了一些工作注意事项，包括打卡等，然后再在HR的帮助下加入了工作的钉钉群。</p><p>之后，在部门的HRBP的带领下回到自己所在的部门，领取了自己的工作电脑（一个比较旧的ThinkPad),然后带领我到了自己的工位。我所在的公共安全与智能交通事业群挺大的有600多号人，其中我所在的平安事业部也有150左右的人员。</p><p>在这里我认识我的杨导师，我所在部门唯一一个Android开发工程师。我看了一下整个集团包括我一个才7个Android开发。</p><p>在进行简单的收拾之后，我开始了配置我的开发环境。刚开始并不是很熟悉，我以为我这台电脑需要密码才能打开，最后在我的摸索下我成功在域环境下注册了我的账号，打开这台工作电脑。</p><p>看着这台电脑里的内容我摸索了一会，主要有许多东西不知道不清楚是干嘛的。在我的磕磕碰碰下，终于我在下午配置好了Android的开发环境。</p><h2 id="实习第二天-2024-7-22"><a href="#实习第二天-2024-7-22" class="headerlink" title="实习第二天 2024-7-22"></a>实习第二天 2024-7-22</h2><p>在今天早上，我开始测试我的Android的开发环境，创建了一个新的项目。可惜不知道这台电脑怎么开启VPN，下载一些依赖库（Google是国外的）就很慢下不成功，试了好久。最后才想到给这些依赖库下载配了个国内的镜像源。最后终于成功了。</p><p>然后下午我去问导师配好环境之后需要干些什么，他说要我开通桌面云（我开始听错了以为云管家），搞了半天才知道搞错了。最后在导师的讲解下终于正确开通的桌面云进行域开发平台的权限。说到权限，我想到了我连开门的权限都没有，每次都等人给我开门，最后在HRBP的帮助下，在钉钉申请了一个园区门禁权限钉单，审批完才开通门禁。在一系列探索下，我终于开始熟练了。我自己开通svn账号，在域开发平台拉取了代码。但是由于域开发环境不能访问外网，只能访问公司内网，我配置了一系列环境之后，配置AndroidStudio的环境有点不知如何做起，然后我询问导师如何解决，他给了我演示和讲解。然后我开始了我艰难的环境配置，我在IT库下载了gradle和AndroidSDK，最后也算成功了吧。虽然也有点版本问题，但是IT库里gradle版本就是比较低级，没办法下其他的只能凑合用。没网的环境确实难受（可能要保密的原因吧）。然后我问导师要了公司的镜像库地址，下载公司库的依赖快了一点。终于忙碌一天终于把开发环境配好了。</p><h2 id="实习第三天-2024-7-23"><a href="#实习第三天-2024-7-23" class="headerlink" title="实习第三天 2024-7-23"></a>实习第三天 2024-7-23</h2><p>在一片误打误撞不断沟通中，终于了解了svn的作用（和git一样都是用来代码开发过程中进行版本控制的）。同时也在IT工单中审批通过园区门禁把进出的门禁权限激活了，终于不用等别人给我开门了。</p><p>在域环境下阅读svn拉取下来的代码，熟悉项目代码，主要阅读了APP模块中的一些主要业务。了解了主要的软件界面实现功能，主要学会了利用大疆SDK和28181SDK进行注册登录并把相关信息保存起来，以及如何获取网络状态和位置信息。查看了一些常量代码和一些BaseActivity等，以及如何获取一些设备信息。</p><h2 id="实习第四天-2024-7-24"><a href="#实习第四天-2024-7-24" class="headerlink" title="实习第四天 2024-7-24"></a>实习第四天 2024-7-24</h2><p>继续阅读学习无人机代码，主要阅读了如何利用RTK和GPS定位，以及拍摄的视频流的处理。学习了一些RxJava和eventBus的知识，了解了RTK和GPS进行定位的一些知识，熟悉了代码中RTK和GPS给无人机进行定位的实现（但还是有一些不会的地方，比如RTK去抖）,阅读了无人机视频处理代码，但是对其视频流的处理大部分不是很会，比如使用H264编码视频流。仔细阅读了文件&#x2F;目录处理工具，了解了侧边栏一些设置界面的实现。</p><h2 id="实习第五天-2024-7-25"><a href="#实习第五天-2024-7-25" class="headerlink" title="实习第五天 2024-7-25"></a>实习第五天 2024-7-25</h2><p>申请禅道账号，写日志和周报。继续熟悉项目代码，了解大疆v5-sdk的主要功能的实现。完成前几天的禅道日志和周报。熟悉大疆SDK,熟悉RTK坐标系和RTK服务器选择，了解一些java&#x2F;kotlin关键字，如JvmOverloads,@IntDef,@Retention等知识。了解了一些动画如何实现的，学习了如何利用Alog通过编程进行日志分析，简化日志分析形式。</p>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高新兴 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HarmonyOS-ArkTS语法</title>
      <link href="/2024/07/03/HarmonyOS-ArkTS%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/07/03/HarmonyOS-ArkTS%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>ArkTS在TypeScript(简称TS)生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升程序执行稳定性和性能。</p><p><img src="https://image.liumingzhi.cn/file/4e0fb5d16ea0b39bb239d.png"></p><p>在UI开发框架中，ArkTS主要扩展了如下能力：</p><ul><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-basic-syntax-overview-V5">基本语法</a>：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-state-management-overview-V5">状态管理</a>：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活地利用这些能力来实现数据和UI的联动。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-rendering-control-overview-V5">渲染控制</a>：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。</li></ul><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p><strong>声明</strong></p><p>ArkTS通过声明引入变量、常量、函数和类型。</p><p><strong>变量声明</strong></p><p>以关键字let开头的声明引入变量，该变量在程序执行期间可以具有不同的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let hi: string = &#x27;hello&#x27;;</span><br><span class="line">hi = &#x27;hello, world&#x27;;</span><br></pre></td></tr></table></figure><p><strong>常量声明</strong></p><p>以关键字const开头的声明引入只读常量，该常量只能被赋值一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hello: string = &#x27;hello&#x27;;</span><br></pre></td></tr></table></figure><p>对常量重新赋值会造成编译时错误。</p>]]></content>
      
      
      <categories>
          
          <category> HarmonyOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HarmonyOS </tag>
            
            <tag> ArkTS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android三种动画学习</title>
      <link href="/2024/06/18/Android%E4%B8%89%E7%A7%8D%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/06/18/Android%E4%B8%89%E7%A7%8D%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Android的动画分为了三种， 分别是 帧动画、View动画（补间动画）、属性动画。</p><h3 id="1、帧动画"><a href="#1、帧动画" class="headerlink" title="1、帧动画"></a>1、帧动画</h3><p>帧动画就是顺序播放一组预先定义好的图片，就类似于我们观看视频，就是一张一张的图片连续播放。</p><p>帧动画的使用很简单，总共就两个步骤：</p><p>1、在res&#x2F;drawable目录下定义一个XML文件，根节点为系统提供的animation-list，然后放入定义更好的图片；<br>2、使用AnimationDrawable类播放第一步定义好的Drawable中的图片，形成动画效果</p><h3 id="2、View动画（也称补间动画）"><a href="#2、View动画（也称补间动画）" class="headerlink" title="2、View动画（也称补间动画）"></a>2、View动画（也称补间动画）</h3><h4 id="2-1-View动画的基本介绍"><a href="#2-1-View动画的基本介绍" class="headerlink" title="2.1 View动画的基本介绍"></a>2.1 View动画的基本介绍</h4><p>view动画也称为补间动画，因为我们只需要拿到一个view，设定它开始和结束的位置，中间的view会自动由系统补齐，而不需要帧动画每一幅图都是提前准备好的。</p><p>View动画是Android一开始就提供的比较原始的动画，主要支持四种效果：平移、缩放、旋转、透明度变化（渐变） 四种基本效果，我们可以再这四种基础效果的基础上，选择其中的几种进行组合。</p><p>View动画的四种基本效果对应了四个Animation的子类，如下：<br><img src="https://image.liumingzhi.cn/file/1107f541de8a7cd1f3f63.png"></p><h3 id="3、属性动画"><a href="#3、属性动画" class="headerlink" title="3、属性动画"></a>3、属性动画</h3><p>属性动画可以看作是增强版的补间动画，与补间动画的不同之处体现在：</p><p>补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。<br>补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。<br>与补间动画类似的是，属性动画也需要定义几个方面的属性：</p><p>动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。<br>动画插值方式。通过 android:interploator 指定。<br>动画重复次数。通过 android:repeatCount 指定。<br>重复行为。通过 android:repeatMode 指定。<br>动画集。在属性资源文件中通过 &lt;set …&#x2F;&gt; 来组合。<br>帧刷新率。指定多长时间播放一帧。默认为 10 ms。<br>属性动画 API</p><p>Animator: 提供创建属性动画的基类，基本不会直接使用这个类。<br>ValueAnimator:属性动画用到的主要的时间引擎，负责计算各个帧的属性值，基本上其他属性动画都会直接或间接继承它；<br>ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。<br>AnimatorSet：Animator 的子类，用于组合多个 Animator。<br>除了这些 API,属性动画还提供了一个 Evaluator ，用来控制属性动画如何计算属性值。</p><p>IntEvaluator:计算 int 类型属性值的计算器。<br>FloatEvaluator: 用于计算 float 类型属性值的计算器。<br>ArgbEvaluator: 用于计算十六进制形式表示的颜色值的计算器。<br>TypeEvaluator: 可以自定义计算器。<br>使用 ValueAnimator 创建动画的步骤：</p><p>调用 ValueAnimator 的 ofInt()、ofFloat() 或者 ofObject() 静态方法创建 ValueAnimator 实例。<br>调用 ValueAnimator 的 setXxx() 等方法设置持续时间，插值方式、重复次数等。<br>调用 ValueAnimator 的 start() 方法启动动画。<br>为 ValueAnimator 注册 AnimatorUpdateListener 监听器，在该监听器中可以监听 ValueAnimator 计算出来的值改变，并将这些值应用到指定对象上。<br>属性动画的一般使用：</p><p>定义属性动画和补间动画等类似，有两种方式：</p><p>使用 ValueAnimator 或者 ObjectAnimator 的静态工厂方法创建动画。<br>使用资源文件来定义动画。<br>属性动画的使用：</p><p>创建 ValueAnimator 或 ObjectAnimator 对象 —— 即可以从 XML 资源文件加载该动画也可以直接调用 ValueAnimator 或者 ObjectAnimator 的静态工厂方法创建动画。<br>根据需要为 Animator 对象设置属性。<br>如果需要监听 Animator 的动画开始事件，动画结束事件、动画重复事件、动画值改变事件，并根据事件提供响应处理代码，需要为Animator 对象设置监听器。<br>如果有多个动画需要同时播放，需要使用 AnimatorSet 组合这些动画。<br>调用 Animator 对象的 start 启动动画。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/06/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/06/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>一共23种设计模式，三种类型模式：创建型模式（5），结构型模式（7），行为型模式（11）。</p><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h2 id="设计模式的七大原则："><a href="#设计模式的七大原则：" class="headerlink" title="设计模式的七大原则："></a>设计模式的七大原则：</h2><p>●开闭原则：对扩展开发，对修改关闭</p><p>●单一职责原则：一个类只负责一个功能领域的相应职责</p><p>●里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象</p><p>●依赖倒转原则：依赖于抽象，不能依赖于具体实现</p><p>●接口隔离原则：类之间的依赖关系应该建立在最小的接口上</p><p>●合成&#x2F;聚合复用原则：尽量使用合成&#x2F;聚合，而不是通过继承达到复用的目的</p><p>●迪米特原则：一个软件实体应该尽可能少的与其他实体发生相互作用</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="1-工厂模式："><a href="#1-工厂模式：" class="headerlink" title="1.工厂模式："></a>1.工厂模式：</h3><h4 id="1-1-简单工厂模式："><a href="#1-1-简单工厂模式：" class="headerlink" title="1.1 简单工厂模式："></a>1.1 简单工厂模式：</h4><p><strong>定义:</strong> 定义了一个创建对象的类，由这个类来封装实例化对象的行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SimplePizzaFactory &#123;</span><br><span class="line">       public Pizza CreatePizza(String ordertype) &#123;</span><br><span class="line">              Pizza pizza = null;</span><br><span class="line">              if (ordertype.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">                     pizza = new CheesePizza();</span><br><span class="line">              &#125; else if (ordertype.equals(&quot;greek&quot;)) &#123;</span><br><span class="line">                     pizza = new GreekPizza();</span><br><span class="line">              &#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;</span><br><span class="line">                     pizza = new PepperPizza();</span><br><span class="line">              &#125;</span><br><span class="line">              return pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单工厂存在的问题与解决方法</strong>： 简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以，从设计角度考虑，有一定的问题，如何解决？我们可以定义一个创建对象的抽象方法并创建多个不同的工厂类实现该抽象方法，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。这种方法也就是我们接下来要说的工厂方法模式</p><h4 id="1-2-工厂方法模式："><a href="#1-2-工厂方法模式：" class="headerlink" title="1.2 工厂方法模式："></a>1.2 工厂方法模式：</h4><p><strong>定义:</strong> 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide - 一个好用的图片加载库</title>
      <link href="/2024/06/17/Glide%20-%20%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93/"/>
      <url>/2024/06/17/Glide%20-%20%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="关于-Glide"><a href="#关于-Glide" class="headerlink" title="关于 Glide"></a>关于 Glide</h3><p>Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（<code>decode pipeline</code>），以及自动的资源池技术。</p><p>Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于<code>HttpUrlConnection</code>的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。</p><p>虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取&#x2F;缩放&#x2F;显示的一切需求。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>多数情况下，使用Glide加载图片非常简单，一行代码足矣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(fragment)</span><br><span class="line">    .load(myUrl)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure><p>取消加载同样很简单：</p><p><code>Glide.with(fragment).clear(imageView);</code></p><p>尽管及时取消不必要的加载是很好的实践，但这并不是必须的操作。实际上，当 [<code>Glide.with()</code>][1] 中传入的 Activity 或 Fragment 实例销毁时，Glide 会自动取消加载并回收资源。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>Glide 充分考虑了Android图片加载性能的两个关键方面：</p><ul><li>图片解码速度</li><li>解码图片带来的资源压力</li></ul><p>为了让用户拥有良好的App使用体验，图片不仅要快速加载，而且还不能因为过多的主线程I&#x2F;O或频繁的垃圾回收导致页面的闪烁和抖动现象。</p><p>Glide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：</p><ul><li>自动、智能地下采样(<code>downsampling</code>)和缓存(<code>caching</code>)，以最小化存储开销和解码次数；</li><li>积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；</li><li>深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理名词解释</title>
      <link href="/2024/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
      <url>/2024/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h3 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1)前缀</span><br><span class="line">答：前缀——是指符号串任意首部。</span><br><span class="line">2)可归前缀</span><br><span class="line">答：可归前缀——是指规范句型的一个前缀，这种前缀包含句柄且不含句柄之后的任何符号。</span><br><span class="line">3)活前缀</span><br><span class="line">答：活前缀——规范句型的一个前缀，这种前缀不含句柄之后的任何符号。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">或给定文法规范句型的可归前缀的任意首部。</span><br><span class="line">4)简单短语</span><br><span class="line">答：简单短语——设G[Z]是给定文法,w=xuy∈V+，为该文法的句型,如果满足下面两个条件:</span><br><span class="line">① Z  xUy；     ② Uu；</span><br><span class="line">            则称句型xuy 中的子串u是句型xuy的简单短语。</span><br><span class="line">5)扫描遍</span><br><span class="line">答：扫描遍——指编译程序对源程序或中间代码程序从头到尾扫描一次。</span><br><span class="line">6)句柄</span><br><span class="line">答：句柄——给定句型中的最左简单短语就是句柄。</span><br><span class="line">7)句型</span><br><span class="line">答：句型——设G是一个给定的文法，S是文法的开始符号，如果Sx(其中x∈V*),则称x是文法的一个句型。</span><br><span class="line">8)句子</span><br><span class="line">答：句子——设G是一个给定的文法，S是文法的开始符号，如果S   x（其中x∈VT*），则称x是文法的一个句子。</span><br><span class="line">9)非终结符</span><br><span class="line">答：非终结符—出现在文法产生式的左部且能派生出符号或符号串的那些符号称为非终结符号。</span><br><span class="line">10)终结符</span><br><span class="line">答：终结符——出现在文法产生式的右部且不能派生出符号或符号串的那些符号称为终结符号。</span><br><span class="line">11）属性文法</span><br><span class="line">答：一个属性文法形式的定义为一个三元组AG，AG=（G，V，E）。</span><br><span class="line">      其中G为一个上下文无关文法；V为属性的有穷集；E为一组语义规则。</span><br><span class="line">12）语法制导翻译</span><br><span class="line">答：语法制导翻译——语法制导翻译就是在语法分析的过程中，当进行推导或归约时同步完成附加在所使用的产生式上的语义规则描述的动作，从而实现语义处理。</span><br><span class="line">13）后缀式</span><br><span class="line">答：后缀式——一种把运算量（操作数）写在前面，把算符写在后面（后缀）的表示法。</span><br><span class="line">14）短语</span><br><span class="line">答：短语——设G[Z]是给定文法,w=xuy∈V+，为该文法的句型,如果满足下面两个条件:</span><br><span class="line">① Z  xUy；     ② U  u；</span><br><span class="line">            则称句型xuy 中的子串u是句型xuy的短语。</span><br><span class="line">或：句型语法树的全部子树的叶从左到右排列起来构成的符号串均是句型的短语。</span><br><span class="line">15）基本块</span><br><span class="line">答：基本块——源程序或者中间代码程序中只有一个入口和一个出口的顺序执行的代码段。</span><br><span class="line">16）语义规则</span><br><span class="line">答：对于文法的每个产生式都配备了一组属性的计算规则，称为语义规则。</span><br><span class="line">17）语法分析</span><br><span class="line">答：语法分析——按文法的产生式识别输入的符号串是否为一个句子的分析过程。</span><br><span class="line">18）四元式</span><br><span class="line">答：四元式——是一个带有四个域的记录结构，这四个域分别称为操作符域、左运算对象域、右运算对象域及运算结果域。</span><br><span class="line">二．简答题：</span><br><span class="line">什么是句子？ 什么是语言?</span><br><span class="line">解答：句子——设G是一个给定的文法，S是文法的开始符号，如果S   x（其中x∈VT*），则称x是文法的一个句子。</span><br><span class="line">语言——语言是句子的集合。</span><br><span class="line">或——设G[S]是给定文法，则由文法G所定义的语言L(G)可描述为：L(G)＝&#123;x│Sx,x∈VT*&#125; 。</span><br><span class="line">DFA与NFA有何区别 ?</span><br><span class="line">解答:DFA与NFA的区别表现为两个方面:一是NFA可以有若干个开始状态，而DFA仅只有一个开始状态。另一方面，DFA的映象M是从K×∑到K，而NFA的映象M是从K×∑到K的子集，即映象M将产生一个状态集合（可能为空集），而不是单个状态。</span><br><span class="line">自顶向下的语法分析方法的基本思想是什么?</span><br><span class="line">解答:从文法的开始符号开始，根据给定的输入串并按照文法的产生式一步一步的向下进行直接推导，试图推导出文法的句子，使之与给定的输入串匹配。</span><br><span class="line">自底向上的语法分析方法的基本思想是什么?</span><br><span class="line">解答:从给定的输入串（终结符串）开始，根据文法的规则一步一步的向上进行直接归约，试图归约到文法的开始符号。</span><br><span class="line">一个上下文无关文法G包括哪四个组成部分？</span><br><span class="line">解答:一组非终结符号，一组终结符号，一个开始符号，以及一组产生式。</span><br><span class="line">在自底向上的语法分析方法中，分析的关键是什么？</span><br><span class="line">解答:关键是寻找句柄。</span><br><span class="line">在自顶向下的语法分析方法中，分析的关键是什么？</span><br><span class="line">解答:关键是选择候选式。</span><br><span class="line">编译程序中语法分析器接收以什么为单位的输入？</span><br><span class="line">解答: 接收以单词为单位的输入。</span><br><span class="line">若一个文法是递归的，则它所产生的语言的句子是可枚举的吗？</span><br><span class="line">解答: 它所产生的语言的句子不是可枚举的，而是无穷多个。</span><br><span class="line">编译程序生成的目标程序是不是一定是机器语言的程序？</span><br><span class="line">解答:不一定是机器语言的程序。</span><br><span class="line">词法分析器是用于做什么的？</span><br><span class="line">解答:词法分析器是用于识别单词的。</span><br><span class="line">“用高级语言书写的源程序都必须通过编译,产生目标代码后才能投入运行”这种说法正确吗？</span><br><span class="line">解答: 不正确。</span><br><span class="line">把汇编语言程序翻译成机器可执行的目标程序的工作是由什么完成的？</span><br><span class="line">解答: 由汇编器（汇编程序）完成的。</span><br><span class="line">14)图示运行时存储空间的划分（分为哪几个区）。</span><br><span class="line">解答:  一般分为静态区和动态区：</span><br><span class="line">            程序代码区、静态数据区、栈区和堆区</span><br><span class="line">15)词法分析的主要任务是什么？</span><br><span class="line">解答:词法分析器的任务是对构成源程序的字符串从左到右逐个字符逐个字符地进行扫描，依次把它们识别为一个一个具有独立意义的单词，并确定其属性，再转换为长度统一的属性字并输出。</span><br><span class="line">16)常用的中间语言种类有哪几种？</span><br><span class="line">解答: 常用的中间语言种类有逆波兰表示、三元式、四元式和树形表示。</span><br><span class="line">17）文法G所描述的语言是什么的集合？</span><br><span class="line">解答:是由文法的开始符号推出的所有终结符串的集合。或说是句子的集合。</span><br><span class="line">18）乔姆斯基把文法分为四种类型，即0型、1型、2型、3型。其中2型文法叫什么？</span><br><span class="line">解答: 2型文法叫上下文无关文法。</span><br><span class="line">19）编译程序是一种解释程序吗？还是什么程序？</span><br><span class="line">解答:编译程序是一种翻译程序。</span><br><span class="line">20）按逻辑上划分，编译程序第二步工作是什么？</span><br><span class="line">解答: 编译程序第二步工作是语法分析。</span><br><span class="line">21）源程序是用高级语言编写的，目标程序是机器语言程序或汇编语言程序 ，则其翻译程序称为什么？</span><br><span class="line">解答: 其翻译程序称为编译程序。</span><br><span class="line">22）编译方式与解释方式的根本区别为什么？</span><br><span class="line">解答:编译方式与解释方式的根本区别在于是否生成目标代码。</span><br><span class="line">23）常见的动态存贮分配策略有哪两种？</span><br><span class="line">解答:常见的两种动态存贮分配策略是栈式动态分配策略和堆式动态分配策略。</span><br><span class="line">24）常用的参数传递方式有哪三种？</span><br><span class="line">解答:常见的参数传递方式有传地址、传值和传名三种方式。</span><br><span class="line">25）语法分析的任务是什么？</span><br><span class="line">解答:语法分析的任务是识别给定的终结符串是否为给定文法的句子。</span><br><span class="line">26）局部优化是局限于一个什么范围内的一种优化？</span><br><span class="line">解答: 是局限于一个基本块范围内的一种优化。</span><br><span class="line">27）文法等价的定义是什么？</span><br><span class="line">解答: 设G1和G2是给定的文法，如果有L（G1）= L（G2），则称G1与G2等价。</span><br><span class="line">28）在语法分析处理中，FIRST集合、FOLLOW集合、SELECT集合均是什么集合？</span><br><span class="line">解答: 均是终结符集。</span><br><span class="line">29）通常一个编译程序中应包括哪七个部分？</span><br><span class="line">解答: 通常一个编译程序中应包含词法分析，语法分析，语义分析与中间代码生成，代码优化，目标代码生成以及表格处理和出错处理等七个部分。</span><br><span class="line">32）如果编译程序生成的目标程序是汇编语言程序，则源程序的执行分为哪三个阶段？</span><br><span class="line">解答: 源程序的执行分为三个阶段: 编译阶段，汇编阶段和运行阶段。</span><br><span class="line">33）翻译程序是这样一种程序，它能够将用什么转换成与其等价的用乙语言书写的程序？</span><br><span class="line">解答:能够将用甲语言书写的程序转换成与其等价的用乙语言书写的程序。</span><br><span class="line">34）说明下面文法G[S]是二义性文法：S→SaS|SbS|cSd|eS|f</span><br><span class="line">解答:fafbf是文法G[S]的一个句子，并且有两个不同的最右推导。</span><br><span class="line">（1）S =&gt; SaS =&gt; SaSbS =&gt; SaSbf=&gt; Safbf=&gt; fafbf</span><br><span class="line">    （2）S =&gt; SbS =&gt; Sbf=&gt; SaSbf =&gt; Safbf=&gt; fafbf</span><br><span class="line">因此说明此文法有二义性。</span><br><span class="line">35）在属性文法中，综合属性与继承属性是如何传递信息的？</span><br><span class="line">解答: 综合属性用于自下而上传递信息，继承属性用于自上而下传递信息。</span><br><span class="line">36）代码优化的主要目标是什么？</span><br><span class="line">解答: 代码优化的主要目标是如何提高目标程序的运行速度和如何减少目标程序运行时所需的空间。</span><br><span class="line">37）写一个文法，使其语言是无符号二进制实数（不含指数）。</span><br><span class="line">解答:文法G(N)：</span><br><span class="line">　　　　　 　N→L.L|L</span><br><span class="line">　　　　　 　L→LB|B</span><br><span class="line">　　　　　 　B→0|1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter</title>
      <link href="/2024/06/10/Flutter/"/>
      <url>/2024/06/10/Flutter/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Flutter-开发文档参考"><a href="#1-Flutter-开发文档参考" class="headerlink" title="1. Flutter 开发文档参考"></a>1. Flutter 开发文档参考</h2><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">Flutter官方文档</button><button type="button" class="tab " data-href="test1-2">Flutter实战第二版</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://docs.flutter.cn/get-started/codelab"><br>    <div class="tag-link-tips">引用站外地址</div><br>    <div class="tag-link-bottom"><br>        <div class="tag-link-left" style=""><br>          <i class="anzhiyufont anzhiyu-icon-link" style=""></i><br>        </div><br>        <div class="tag-link-right"><br>            <div class="tag-link-title">Flutter官方文档</div><br>            <div class="tag-link-sitename">flutter官方</div><br>        </div><br>        <i class="anzhiyufont anzhiyu-icon-angle-right"></i><br>    </div><br>    </a></div></strong></p></div><div class="tab-item-content" id="test1-2"><p><strong><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://book.flutterchina.club/"><br>    <div class="tag-link-tips">引用站外地址</div><br>    <div class="tag-link-bottom"><br>        <div class="tag-link-left" style=""><br>          <i class="anzhiyufont anzhiyu-icon-link" style=""></i><br>        </div><br>        <div class="tag-link-right"><br>            <div class="tag-link-title">Flutter实战第二版</div><br>            <div class="tag-link-sitename">flutter实战</div><br>        </div><br>        <i class="anzhiyufont anzhiyu-icon-angle-right"></i><br>    </div><br>    </a></div></strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><p class='p center cyan'>我们首先可以根据官方文档按照不同的开发平台搭建自己的学习开放环境</p><h2 id="2-Flutter-开发语言-Dart"><a href="#2-Flutter-开发语言-Dart" class="headerlink" title="2. Flutter 开发语言 : Dart"></a>2. Flutter 开发语言 : Dart</h2><p>要想学习好Flutter跨平台开发，首先需要学会其开发语言。不过语言具有相通性，很快能够学会上手。</p><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://dart.cn/guides">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="">          <i class="anzhiyufont anzhiyu-icon-link" style=""></i>        </div>        <div class="tag-link-right">            <div class="tag-link-title">Dart</div>            <div class="tag-link-sitename">dart</div>        </div>        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>    </div>    </a></div><h2 id="3-Flutter-的简介"><a href="#3-Flutter-的简介" class="headerlink" title="3. Flutter 的简介"></a>3. Flutter 的简介</h2><p>Flutter 是 Google 推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart 语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter 提供了丰富的组件、接口，开发者可以很快地为 Flutter 添加 Native（即原生开发，指基于平台原生语言来开发应用，flutter可以和平台原生语言混合开发） 扩展。</p><h3 id="3-1-Flutter-的特点"><a href="#3-1-Flutter-的特点" class="headerlink" title="3.1 Flutter 的特点"></a>3.1 Flutter 的特点</h3><ol><li>跨平台: <mark class="hl-label default">Android</mark>  <mark class="hl-label blue">ios</mark>  <mark class="hl-label purple">Web</mark>  等平台</li><li>跨平台自绘引擎</li><li>支持Dart语言</li><li>声明式UI</li><li>高性能</li><li>万物都可widget</li></ol><h3 id="3-2-Flutter-框架架构"><a href="#3-2-Flutter-框架架构" class="headerlink" title="3.2 Flutter 框架架构"></a>3.2 Flutter 框架架构</h3><details class="folding-tag" ><summary> Flutter框架架构 </summary>              <div class='content'>              <p>Flutter 官方提供的 Flutter 框架图:</p><p><img src="https://image.liumingzhi.cn/file/78c8b1117466fe4737067.png"></p><h4 id="1-框架层"><a href="#1-框架层" class="headerlink" title="1. 框架层"></a>1. 框架层</h4><p>Flutter Framework，即框架层。这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下：</p><ul><li>底下两层（Foundation 和 Animation、Painting、Gestures）在 Google 的一些视频中被合并为一个dart UI层，对应的是Flutter中的<code>dart:ui</code>包，它是 Flutter Engine 暴露的底层UI库，提供动画、手势及绘制能力。</li><li>Rendering 层，即渲染层，这一层是一个抽象的布局层，它依赖于 Dart UI 层，渲染层会构建一棵由可渲染对象组成的<strong>渲染树</strong>，当动态更新这些对象时，渲染树会找出变化的部分，然后更新渲染。渲染层可以说是Flutter 框架层中最核心的部分，它除了确定每个渲染对象的位置、大小之外还要进行坐标变换、绘制（调用底层 dart:ui ）。</li><li>Widgets 层是 Flutter 提供的一套基础组件库，在基础组件库之上，Flutter 还提供了 Material 和 Cupertino 两种视觉风格的组件库，它们分别实现了 Material 和 iOS 设计规范。</li></ul><p>Flutter 框架相对较小，因为一些开发者可能会使用到的更高层级的功能已经被拆分到不同的软件包中，使用 Dart 和 Flutter 的核心库实现，其中包括平台插件，例如 <a href="https://pub.flutter-io.cn/packages/camera">camera <strong>(opens new window)</strong></a>和 <a href="https://pub.flutter-io.cn/packages/webview_flutter">webview <strong>(opens new window)</strong></a>，以及和平台无关的功能，例如 <a href="https://pub.flutter-io.cn/packages/animations">animations <strong>(opens new window)</strong></a>。</p><p>我们进行Flutter 开发时，大多数时候都是和 Flutter Framework 打交道。</p><h4 id="2-引擎层"><a href="#2-引擎层" class="headerlink" title="2. 引擎层"></a>2. 引擎层</h4><p>Engine，即引擎层。毫无疑问是 Flutter 的核心， 该层主要是 C++ 实现，其中包括了 Skia 引擎、Dart 运行时（Dart runtime）、文字排版引擎等。在代码调用 <code>dart:ui</code>库时，调用最终会走到引擎层，然后实现真正的绘制和显示。</p><h4 id="3-嵌入层"><a href="#3-嵌入层" class="headerlink" title="3. 嵌入层"></a><a href="https://book.flutterchina.club/chapter1/flutter_intro.html#_3-%E5%B5%8C%E5%85%A5%E5%B1%82"></a>3. 嵌入层</h4><p>Embedder，即嵌入层。Flutter 最终渲染、交互是要依赖其所在平台的操作系统 API，嵌入层主要是将 Flutter 引擎 ”安装“ 到特定平台上。嵌入层采用了当前平台的语言编写，例如 Android 使用的是 Java 和 C++， iOS 和 macOS 使用的是 Objective-C 和 Objective-C++，Windows 和 Linux 使用的是 C++。 Flutter 代码可以通过嵌入层，以模块方式集成到现有的应用中，也可以作为应用的主体。Flutter 本身包含了各个常见平台的嵌入层，假如以后 Flutter 要支持新的平台，则需要针对该新的平台编写一个嵌入层。</p>              </div>            </details><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床</title>
      <link href="/2024/06/10/%E5%9B%BE%E5%BA%8A/"/>
      <url>/2024/06/10/%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>主题配置</title>
      <link href="/2024/06/10/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/06/10/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RecyclerView底层实现原理</title>
      <link href="/2024/05/26/RecyclerView%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2024/05/26/RecyclerView%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="RecyclerView-的底层实现原理涉及到一些重要的概念和机制："><a href="#RecyclerView-的底层实现原理涉及到一些重要的概念和机制：" class="headerlink" title="RecyclerView 的底层实现原理涉及到一些重要的概念和机制："></a>RecyclerView 的底层实现原理涉及到一些重要的概念和机制：</h3><ol><li><strong>ViewHolder 模式</strong>：RecyclerView 使用 ViewHolder 模式来缓存列表项的视图对象，以便在滚动列表时能够快速重用视图，减少内存消耗和视图创建的开销。ViewHolder 是一个简单的 Java 对象，持有列表项的视图对象，避免了频繁的 findViewById() 调用，提高了列表的滚动性能。</li><li><strong>回收复用机制</strong>：RecyclerView 内部维护了一个回收池（Recycler），用于存储已经滚出屏幕的列表项的 ViewHolder 对象。当列表项滚出屏幕时，RecyclerView 将其对应的 ViewHolder 放入回收池中，并在需要显示新的列表项时，从回收池中取出可复用的 ViewHolder 对象，避免了频繁地创建和销毁视图对象。</li><li><strong>局部刷新</strong>：RecyclerView 提供了局部刷新的机制，可以精确地更新列表中的某个列表项，而不是刷新整个列表。通过调用 notifyItemChanged()、notifyItemInserted()、notifyItemRemoved() 等方法，可以实现对列表的局部更新，减少了整个列表的刷新操作，提高了列表的性能。</li><li><strong>异步布局计算</strong>：RecyclerView 支持异步布局计算，可以在子线程中进行布局计算和数据处理，避免了在主线程中进行耗时的计算操作，保持了界面的流畅性。通过调用 setHasFixedSize() 方法设置 RecyclerView 的大小固定，可以启用异步布局计算。</li><li><strong>定制化布局管理器</strong>：RecyclerView 允许开发者定制化布局管理器（LayoutManager），以满足不同的布局需求。开发者可以自定义 LayoutManager，实现各种复杂的布局效果，如瀑布流、网格布局等。</li></ol><p>综上所述，RecyclerView 的底层实现原理主要涉及到 ViewHolder 模式、回收复用机制、局部刷新、异步布局计算和定制化布局管理器等重要概念和机制。通过这些机制的配合，RecyclerView 实现了高效的列表布局和数据展示，保证了列表的流畅性和性能。</p><p><img src="https://i2.wp.com/www.andreasjakl.com/wp-content/uploads/2018/01/Android-RecyclerView-Flow.png?ssl=1" alt="[Android] RecyclerView"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android面经</title>
      <link href="/2024/05/21/Android%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/05/21/Android%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Android面经"><a href="#Android面经" class="headerlink" title="Android面经"></a>Android面经</h1><h2 id="一、四大组件"><a href="#一、四大组件" class="headerlink" title="一、四大组件"></a>一、四大组件</h2><h3 id="1、Activity的生命周期"><a href="#1、Activity的生命周期" class="headerlink" title="1、Activity的生命周期"></a>1、Activity的生命周期</h3><ol><li>启动Activity：系统会先调用<strong>onCreate</strong>方法，然后调用<strong>onStart</strong>方法，最后调用<strong>onResume</strong>，Activity进入运行状态。</li><li>当前Activity被其他Activity覆盖其上或被锁屏：系统会调用<strong>onPause</strong>方法，暂停当前Activity的执行。</li><li>当前Activity由被覆盖状态回到前台或解锁屏：系统会调用<strong>onResume</strong>方法，再次进入运行状态。</li><li>当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用<strong>onPause</strong>方法，然后调用<strong>onStop</strong>方法，进入停滞状态。</li><li>用户后退回到此Activity：系统会先调用<strong>onRestart</strong>方法，然后调用<strong>onStart</strong>方法，最后调用<strong>onResume</strong>方法，再次进入运行状态。</li><li>当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用<strong>onCreate</strong>方法、<strong>onStart</strong>方法、<strong>onResume</strong>方法，进入运行状态。</li><li>用户退出当前Activity：系统先调用<strong>onPause</strong>方法，然后调用<strong>onStop</strong>方法，最后调用<strong>onDestory</strong>方法，结束当前Activity。</li></ol><h3 id="2、Activity的四种启动模式"><a href="#2、Activity的四种启动模式" class="headerlink" title="2、Activity的四种启动模式"></a>2、Activity的四种启动模式</h3><ul><li><strong>standard（标准模式）</strong>：如果在mainfest中不设置就默认standard。standard就是新建一个Activity就在栈中新建一个activity实例；</li><li><strong>singleTop（栈顶复用模式）</strong>：与standard相比栈顶复用可以有效减少activity重复创建对资源的消耗，但是这要根据具体情况而定，不能一概而论；</li><li><strong>singleTask（栈内单例模式）</strong>：栈内只有一个activity实例，栈内已存activity实例，在其他activity中start这个activity，Android直接把这个实例上面其他activity实例踢出栈GC掉；</li><li><strong>singleInstance（堆内单例）</strong> ：整个手机操作系统里面只有一个实例存在就是内存单例；如APP经常调用的拨打电话、系统通讯录、系统Launcher、锁屏键、来电显示等系统应用。singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。</li></ul><p>在singleTop、singleTask、singleInstance 中如果在应用内存在Activity实例，并且再次发生startActivity(Intent intent)回到Activity后,由于并不是重新创建Activity而是复用栈中的实例，因此Activity再获取焦点后并没调用onCreate、onStart，而是直接调用了onNewIntent(Intent intent)函数。</p><h2 id="二、View"><a href="#二、View" class="headerlink" title="二、View"></a>二、View</h2><h3 id="1、View的绘制流程"><a href="#1、View的绘制流程" class="headerlink" title="1、View的绘制流程"></a>1、View的绘制流程</h3><p>视图绘制的起点在 ViewRootImpl 类的 <code>performTraversals()</code>方法，在这个方法内其实是按照顺序依次调用了 <code>mView.measure()、mView.layout()、mView.draw()</code></p><p>View的绘制流程分为3步：测量、布局、绘制，分别对应3个方法 measure、layout、draw</p><ul><li><strong>测量阶段</strong>：measure 方法会被父 View 调用，在measure 方法中做一些优化和准备工作后会调用 onMeasure 方法进行实际的自我测量。onMeasure方法在View和ViewGroup做的事情是不一样的：<ul><li><strong>View</strong>：View 中的 onMeasure 方法会计算自己的尺寸并通过 setMeasureDimension 保存。</li><li><strong>ViewGroup</strong>： ViewGroup 中的 onMeasure 方法会调用所有子 View的measure 方法进行自我测量并保存。然后通过子View的尺寸和位置计算出自己的尺寸并保存。</li></ul></li><li><strong>布局阶段</strong>：layout 方法会被父View调用，layout 方法会保存父 View 传进来的尺寸和位置，并调用 onLayout 进行实际的内部布局。onLayout 在 View 和 ViewGroup 中做的事情也是不一样的：<ul><li><strong>View</strong>： 因为 View 是没有子 View 的，所以View的onLayout里面什么都不做。</li><li><strong>ViewGroup</strong> ：ViewGroup 中的 onLayout 方法会调用所有子 View 的 layout 方法，把尺寸和位置传给他们，让他们完成自我的内部布局。</li></ul></li><li><strong>绘制阶段</strong>：draw 方法会做一些调度工作，然后会调用 onDraw 方法进行 View 的自我绘制。draw 方法的调度流程大致是这样的：<ul><li><strong>绘制背景</strong>：对应 <code>drawBackground(Canvas)</code>方法。</li><li><strong>绘制主体</strong>：对应 <code>onDraw(Canvas)</code>方法。</li><li><strong>绘制子View</strong>： 对应 <code>dispatchDraw(Canvas)</code>方法。</li><li><strong>绘制滑动相关和前景</strong>： 对应 <code>onDrawForeground(Canvas)</code></li></ul></li></ul><h3 id="2、MeasureSpec"><a href="#2、MeasureSpec" class="headerlink" title="2、MeasureSpec"></a>2、MeasureSpec</h3><p>MeasureSpec 是 View 的测量规则。通常父控件要测量子控件的时候，会传给子控件 widthMeasureSpec 和 heightMeasureSpec 这两个 int 类型的值。这个值里面包含两个信息，<strong>SpecMode</strong> 和 <strong>SpecSize</strong>。一个 int 值怎么会包含两个信息呢？我们知道 int 是一个4字节32位的数据，在这两个 int 类型的数据中，前面高2位是 <strong>SpecMode</strong> ，后面低30位代表了  <strong>SpecSize</strong>。mode 有三种类型：<code>UNSPECIFIED</code>，<code>EXACTLY</code>，<code>AT_MOST</code></p><ul><li><strong>EXACTLY</strong>：精准模式，当 width 或 height 为固定 xxdp 或者为 MACH_PARENT 的时候，是这种测量模式</li><li><strong>AT_MOST</strong>：当 width 或 height 设置为 warp_content 的时候，是这种测量模式</li><li><strong>UNSPECIFIED</strong>：父容器对当前 View 没有任何显示，子 View 可以取任意大小。一般用在系统内部，比如：Scrollview、ListView。</li></ul><h3 id="3、View的事件分发机制"><a href="#3、View的事件分发机制" class="headerlink" title="3、View的事件分发机制"></a>3、View的事件分发机制</h3><p>在我们的手指触摸到屏幕的时候，事件其实是通过 <code>Activity -&gt; ViewGroup -&gt; View</code> 这样的流程到达最后响应我们触摸事件的 View。</p><p>说到事件分发，必不可少的是这几个方法：<code>dispatchTouchEvent()、onInterceptTouchEvent()、onTouchEvent。</code>接下来就按照<code>Activity -&gt; ViewGroup -&gt; View</code> 的流程来大致说一下事件分发机制。</p><p>我们的手指触摸到屏幕的时候，会触发一个 Action_Down 类型的事件，当前页面的 Activity 会首先做出响应，也就是说会走到 Activity 的 <code>dispatchTouchEvent()</code> 方法内。在这个方法内部简单来说是这么一个逻辑：</p><ul><li>调用 <code>getWindow.superDispatchTouchEvent()。</code></li><li>如果上一步返回 true，直接返回 true；否则就 return 自己的 <code>onTouchEvent()。</code> 这个逻辑很好理解，<code>getWindow().superDispatchTouchEvent()</code> 如果返回 true 代表当前事件已经被处理，无需调用自己的 onTouchEvent；否则代表事件并没有被处理，需要 Activity 自己处理，也就是调用自己的 onTouchEvent。</li></ul><p><code>getWindow()</code>方法返回了一个 Window 类型的对象，这个我们都知道，在 Android 中，PhoneWindow 是Window 的唯一实现类。所以这句本质上是调用了<code>PhoneWindow</code>中的<code>superDispatchTouchEvent()</code>。</p><p>而在 PhoneWindow 的这个方法中实际调用了<code>mDecor.superDispatchTouchEvent(event)</code>。这个 mDecor 就是 DecorView，它是 FrameLayout 的一个子类，在 DecorView 中的 <code>superDispatchTouchEvent()</code> 中调用的是 <code>super.dispatchTouchEvent()</code>。到这里就很明显了，DecorView 是一个 FrameLayout 的子类，FrameLayout 是一个 ViewGroup 的子类，本质上调用的还是 <code>ViewGroup的dispatchTouchEvent()</code>。</p><p>分析到这里，我们的事件已经从 Activity 传递到了 ViewGroup，接下来我们来分析下 ViewGroup 中的这几个事件处理方法。</p><p>在 ViewGroup 中的 <code>dispatchTouchEvent()</code>中的逻辑大致如下：</p><ul><li>通过 <code>onInterceptTouchEvent()</code> 判断当前 ViewGroup 是否拦截事件，默认的 ViewGroup 都是不拦截的；</li><li>如果拦截，则 return 自己的 <code>onTouchEvent()</code>；</li><li>如果不拦截，则根据 <code>child.dispatchTouchEvent()</code>的返回值判断。如果返回 true，则 return true；否则 return 自己的 <code>onTouchEvent()</code>，在这里实现了未处理事件的向上传递。</li></ul><p>通常情况下 ViewGroup 的 <code>onInterceptTouchEvent()</code>都返回 false，也就是不拦截。这里需要注意的是事件序列，比如 Down 事件、Move 事件……Up事件，从 Down 到 Up 是一个完整的事件序列，对应着手指从按下到抬起这一系列的事件，如果 ViewGroup 拦截了 Down 事件，那么后续事件都会交给这个 ViewGroup的onTouchEvent。如果 ViewGroup 拦截的不是 Down 事件，那么会给之前处理这个 Down 事件的 View 发送一个 Action_Cancel 类型的事件，通知子 View 这个后续的事件序列已经被 ViewGroup 接管了，子 View 恢复之前的状态即可。</p><p>这里举一个常见的例子：在一个 Recyclerview 钟有很多的 Button，我们首先按下了一个 button，然后滑动一段距离再松开，这时候 Recyclerview 会跟着滑动，并不会触发这个 button 的点击事件。这个例子中，当我们按下 button 时，这个 button 接收到了 Action_Down 事件，正常情况下后续的事件序列应该由这个 button处理。但我们滑动了一段距离，这时 Recyclerview 察觉到这是一个滑动操作，拦截了这个事件序列，走了自身的 <code>onTouchEvent()</code>方法，反映在屏幕上就是列表的滑动。而这时 button 仍然处于按下的状态，所以在拦截的时候需要发送一个 Action_Cancel 来通知 button 恢复之前状态。</p><p>事件分发最终会走到 View 的 <code>dispatchTouchEvent()</code>中。在 View 的 <code>dispatchTouchEvent()</code> 中没有 <code>onInterceptTouchEvent()</code>，这也很容易理解，View 不是 ViewGroup，不会包含其他子 View，所以也不存在拦截不拦截这一说。忽略一些细节，View 的 <code>dispatchTouchEvent()</code>中直接 return 了自己的 <code>onTouchEvent()</code>。如果 <code>onTouchEvent()</code>返回 true 代表事件被处理，否则未处理的事件会向上传递，直到有 View 处理了事件或者一直没有处理，最终到达了 Activity 的 <code>onTouchEvent()</code> 终止。</p><p>这里经常有人问 onTouch 和 onTouchEvent 的区别。首先，这两个方法都在 View 的 <code>dispatchTouchEvent()</code>中，是这么一个逻辑：</p><ul><li>如果 touchListener 不为 null，并且这个 View 是 enable 的，而且 onTouch 返回的是 true，满足这三个条件时会直接 return true，不会走 <code>onTouchEvent()</code>方法。</li><li>上面只要有一个条件不满足，就会走到 <code>onTouchEvent()</code>方法中。所以 onTouch 的顺序是在 onTouchEvent 之前的。</li></ul><h3 id="4、dp-和-sp-的区别"><a href="#4、dp-和-sp-的区别" class="headerlink" title="4、dp 和 sp 的区别"></a>4、dp 和 sp 的区别</h3><ul><li><p>dp：一种基于屏幕密度的抽象单位。在每英寸160点的显示器上，1dp&#x3D;1px。不同设备有不同的显示效果，这个和设备硬件有关，<strong>px&#x3D; dp （dpi&#x2F;160）</strong></p></li><li><p>sp：主要用于字体显示，与刻度无关的一种像素，与dp类似，但会随着系统的字体大小改变</p></li></ul><h2 id="三、线程与进程"><a href="#三、线程与进程" class="headerlink" title="三、线程与进程"></a>三、线程与进程</h2><h3 id="1、Bundle机制"><a href="#1、Bundle机制" class="headerlink" title="1、Bundle机制"></a>1、Bundle机制</h3><p>Bundle实现了Parcelable接口，所以他可以方便的在不同进程间传输，这里要注意我们传输的数据必须能够被序列化；</p><ul><li>使用场景：<ul><li>Activity状态数据的保存与恢复涉及到的两个回调：void onSaveInstanceState (Bundle outState)、void onCreate (Bundle savedInstanceState)</li><li>Fragment的setArguments方法：void setArguments (Bundle args)</li><li>消息机制中的Message的setData方法：void setData (Bundle data)</li></ul></li><li>Bundle底层使用的是ArrayMap，这个集合类存储的也是键值对，但是与HashMap不同的是，HashMap采用的是“数组+链表”的方式存储，而ArrayMap中使用的是两个数组进行存储，一个数组存储key，一个数组存储value，内部的增删改查都将会使用二分查找来进行，这个和SparseArray差不多，只不过SparseArray的key值只能是int型的，而ArrayMap可以是Map型，所以在数据量不大的情况下可以使用这两个集合代替HashMap去优化性能；</li></ul><h3 id="2、Handler机制"><a href="#2、Handler机制" class="headerlink" title="2、Handler机制"></a>2、Handler机制</h3><p>Handler的作用是负责跨线程通信，这是因为在主线程不能做耗时操作，而子线程不能更新 UI，所以当子线程中进行耗时操作后需要更新 UI时，通过 Handler 将有关 UI 的操作切换到主线程中执行。</p><p>说到 Handler，就不得不提与之密切相关的这几个类：Message、MessageQueue，Looper。</p><ul><li><strong>Message</strong>：Message 中有两个成员变量值得关注：target 和 callback。<ul><li>target 其实就是发送消息的 Handler 对象</li><li>callback 是当调用 <code>handler.post(runnable)</code> 时传入的 Runnable 类型的任务。post 事件的本质也是创建了一个 Message，将我们传入的这个 runnable 赋值给创建的Message的 callback 这个成员变量。</li></ul></li><li><strong>MessageQueue</strong>: 消息队列很明显是存放消息的队列，值得关注的是 MessageQueue 中的 <code>next()</code> 方法，它会返回下一个待处理的消息。</li><li><strong>Looper</strong>：Looper 消息轮询器其实是连接 Handler 和消息队列的核心。如果想要在一个线程中创建一个 Handler，首先要通过<code>Looper.prepare()</code>创建 Looper，之后还得调用<code>Looper.loop()</code>开启轮询。<ul><li>**<code>prepare()</code>**： 这个方法做了两件事：首先通过<code>ThreadLocal.get()</code>获取当前线程中的Looper，如果不为空，则会抛出一个RunTimeException，意思是一个线程不能创建2个Looper。如果为null则执行下一步。第二步是创建了一个Looper，并通过 <code>ThreadLocal.set(looper)。</code>将我们创建的Looper与当前线程绑定。这里需要提一下的是消息队列的创建其实就发生在Looper的构造方法中。</li><li>**<code>loop()</code>**： 这个方法开启了整个事件机制的轮询。它的本质是开启了一个死循环，不断的通过 <code>MessageQueue的next()</code>方法获取消息。拿到消息后会调用 <code>msg.target.dispatchMessage()</code>来做处理。其实我们在说到 Message 的时候提到过，<code>msg.target</code> 其实就是发送这个消息的 handler。这句代码的本质就是调用 <code>handler的dispatchMessage()。</code></li></ul></li><li><strong>Handler</strong>：Handler 的分析着重在两个部分：发送消息和处理消息。<ul><li><strong>发送消息</strong>：其实发送消息除了 sendMessage 之外还有 sendMessageDelayed 和 post 以及 postDelayed 等等不同的方式。但它们的本质都是调用了 sendMessageAtTime。在 sendMessageAtTime 这个方法中调用了 enqueueMessage。在 enqueueMessage 这个方法中做了两件事：通过<code>msg.target = this</code>实现了消息与当前 handler 的绑定。然后通过<code>queue.enqueueMessage</code>实现了消息入队。</li><li><strong>处理消息</strong>： 消息处理的核心其实就是<code>dispatchMessage()</code>这个方法。这个方法里面的逻辑很简单，先判断 <code>msg.callback</code> 是否为 null，如果不为空则执行这个 runnable。如果为空则会执行我们的<code>handleMessage</code>方法。</li></ul></li></ul><h3 id="3、Looper死循环为什么不会导致应用卡死，即使不会的话，它会慢慢的消耗越来越多的资源吗？"><a href="#3、Looper死循环为什么不会导致应用卡死，即使不会的话，它会慢慢的消耗越来越多的资源吗？" class="headerlink" title="3、Looper死循环为什么不会导致应用卡死，即使不会的话，它会慢慢的消耗越来越多的资源吗？"></a>3、Looper死循环为什么不会导致应用卡死，即使不会的话，它会慢慢的消耗越来越多的资源吗？</h3><ul><li>对于线程即是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，<code>binder</code>线程也是采用死循环的方法，通过循环方式不同与<code>Binder</code>驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。真正会卡死主线程的操作是在回调方法<code>onCreate/onStart/onResume</code>等操作时间过长，会导致掉帧，甚至发生<code>ANR</code>，<code>looper.loop</code>本身不会导致应用卡死。</li><li>主线程的死循环一直运行是不是特别消耗CPU资源呢？ 其实不然，这里就涉及到<code>Linux pipe/epoll</code>机制，简单说就是在主线程的<code>MessageQueue</code>没有消息时，便阻塞在<code>loop</code>的<code>queue.next()</code>中的<code>nativePollOnce()</code>方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的<code>epoll</code>机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I&#x2F;O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</li></ul><h3 id="4、主线程的消息循环机制是什么？"><a href="#4、主线程的消息循环机制是什么？" class="headerlink" title="4、主线程的消息循环机制是什么？"></a>4、主线程的消息循环机制是什么？</h3><p>事实上，会在进入死循环之前便创建了新binder线程，在代码<code>ActivityThread.main()</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//创建Looper和MessageQueue对象，用于处理主线程的消息</span></span><br><span class="line">  Looper.prepareMainLooper();</span><br><span class="line">   <span class="comment">//创建ActivityThread对象</span></span><br><span class="line">   <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>(); </span><br><span class="line">   <span class="comment">//建立Binder通道 (创建新线程)</span></span><br><span class="line">   thread.attach(<span class="literal">false</span>);</span><br><span class="line">   Looper.loop(); <span class="comment">//消息循环运行</span></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>Activity的生命周期都是依靠主线程的</strong> <code>Looper.loop</code>，当收到不同<code>Message</code>时则采用相应措施：一旦退出消息循环，那么你的程序也就可以退出了。 从消息队列中取消息可能会阻塞，取到消息会做出相应的处理。如果某个消息处理时间过长，就可能会影响UI线程的刷新速率，造成卡顿的现象。</p><p><code>thread.attach(false)</code>方法函数中便会创建一个Binder线程（具体是指<code>ApplicationThread</code>，<code>Binder</code>的服务端，用于接收系统服务<code>AMS</code>发送来的事件），该Binder线程通过<code>Handler</code>将<code>Message</code>发送给主线程。「Activity 启动过程」</p><p>比如收到<code>msg=H.LAUNCH_ACTIVITY</code>，则调用<code>ActivityThread.handleLaunchActivity()</code>方法，最终会通过反射机制，创建<code>Activity</code>实例，然后再执行<code>Activity.onCreate()</code>等方法；</p><p>再比如收到<code>msg=H.PAUSE_ACTIVITY</code>，则调用<code>ActivityThread.handlePauseActivity()</code>方法，最终会执行<code>Activity.onPause()</code>等方法。</p><p>主线程的消息又是哪来的呢？当然是App进程中的其他线程通过Handler发送给主线程进程。</p><h3 id="5、Handler同步屏障是什么"><a href="#5、Handler同步屏障是什么" class="headerlink" title="5、Handler同步屏障是什么"></a>5、Handler同步屏障是什么</h3><ul><li><p>Handler Message 种类</p><p>Handler的Message种类分为3种：</p><ul><li><p>普通消息</p></li><li><p>屏障消息</p></li><li><p>异步消息</p></li></ul></li></ul><p>​其中普通消息又称为同步消息，屏障消息又称为同步屏障。</p><p>​我们通常使用的都是普通消息，而屏障消息就是在消息队列中插入一个屏障，在屏障之后的所有普通消息都会被挡着，不能被处理。不过异步消息却例外，屏障不会挡住异步消息，因此可以这样认为：屏障消息就是为了确保异步消息的优先级，设置了屏障后，只能处理其后的异步消息，同步消息会被挡住，除非撤销屏障。</p><ul><li><p>屏障消息如何插入消息队列</p><p>同步屏障是通过MessageQueue的postSyncBarrier方法插入到消息队列的。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">(<span class="type">long</span> when)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> mNextBarrierToken++;</span><br><span class="line">            <span class="comment">//1、屏障消息和普通消息的区别是屏障消息没有tartget。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">            <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="comment">//2、根据时间顺序将屏障插入到消息链表中适当的位置</span></span><br><span class="line">            <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3、返回一个序号，通过这个序号可以撤销屏障</span></span><br><span class="line">            <span class="keyword">return</span> token;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postSyncBarrier方法就是用来插入一个屏障到消息队列的，可以看到它很简单，从这个方法我们可以知道如下：</p><ul><li>屏障消息和普通消息的区别在于屏障没有tartget，普通消息有target是因为它需要将消息分发给对应的target，而屏障不需要被分发，它就是用来挡住普通消息来保证异步消息优先处理的。</li><li>屏障和普通消息一样可以根据时间来插入到消息队列中的适当位置，并且只会挡住它后面的同步消息的分发。</li><li>postSyncBarrier返回一个int类型的数值，通过这个数值可以撤销屏障。</li><li>postSyncBarrier方法是私有的，如果我们想调用它就得使用反射。</li><li>插入普通消息会唤醒消息队列，但是插入屏障不会。</li></ul></li><li><p>屏障消息的工作原理</p><p>我们知道MessageQueue是通过next方法来获取消息的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1、如果有消息被插入到消息队列或者超时时间到，就被唤醒，否则阻塞在这。</span></span><br><span class="line">    nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;<span class="comment">//2、遇到屏障  msg.target == null</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                prevMsg = msg;</span><br><span class="line">                msg = msg.next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">//3、遍历消息链表找到最近的一条异步消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//4、如果找到异步消息</span></span><br><span class="line">            <span class="keyword">if</span> (now &lt; msg.when) &#123;<span class="comment">//异步消息还没到处理时间，就在等会（超时时间）</span></span><br><span class="line">                nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//异步消息到了处理时间，就从链表移除，返回它。</span></span><br><span class="line">                mBlocked = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                    prevMsg.next = msg.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mMessages = msg.next;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                msg.markInUse();</span><br><span class="line">                <span class="keyword">return</span> msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有异步消息就一直休眠，等待被唤醒。</span></span><br><span class="line">            nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注释2如果碰到屏障就遍历整个消息链表找到最近的一条异步消息，在遍历的过程中只有异步消息才会被处理执行到 <code>if (msg != null &amp;&amp; msg.target == null)&#123;&#125;</code>中的代码。</p><p>屏障消息就是通过这种方式就挡住了所有的普通消息。</p></li><li><p>同步屏障的作用</p><p>我们的手机屏幕刷新频率有不同的类型，60Hz、120Hz等。60Hz表示屏幕在一秒内刷新60次，也就是每隔16.6ms刷新一次。屏幕会在每次刷新的时候发出一个 VSYNC 信号，通知CPU进行绘制计算。具体到我们的代码中，可以认为就是执行<code>onMesure()</code>、<code>onLayout()</code>、<code>onDraw()</code>这些方法。view绘制的起点是在 <code>viewRootImpl.requestLayout()</code> 方法开始，这个方法会去执行上面的三大绘制任务，就是测量、布局、绘制。但是调用<code>requestLayout()</code>方法之后，并不会马上开始进行绘制任务，而是会给主线程设置一个同步屏障，并设置 VSYNC 信号监听。当 VSYNC 信号的到来，会发送一个异步消息到主线程Handler，执行我们上一步设置的绘制监听任务，并移除同步屏障。</p></li></ul><h3 id="6、什么是IdleHandler？"><a href="#6、什么是IdleHandler？" class="headerlink" title="6、什么是IdleHandler？"></a>6、什么是IdleHandler？</h3><ul><li><p><strong>介绍</strong>：</p><p><code>IdleHandler</code> 是 <code>MessageQueue</code> 内定义的一个接口，一般可用于做性能优化。当消息队列内没有需要立即执行的 <code>message</code> 时，会主动触发 <code>IdleHandler</code> 的 <code>queueIdle()</code> 方法。返回值为 false，即只会执行一次；返回值为 true，即每次当消息队列内没有需要立即执行的消息时，都会触发该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">IdleHandler</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用方式</strong>：</p><p>通过获取 <code>looper</code> 对应的 <code>MessageQueue</code> 队列注册监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> <span class="title class_">MessageQueue</span>.IdleHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// doSomething()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>源码解析</strong>：</p><p>IdleHandler 的执行源码很短。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 隐藏无关代码...</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">// 隐藏无关代码...</span></span><br><span class="line">        <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">        <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">        <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">        <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">            pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">            mBlocked = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">            mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Run the idle handlers.</span></span><br><span class="line">    <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">        mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            keep = idler.queueIdle();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                mIdleHandlers.remove(idler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">    pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">    <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">    nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 <code>MessageQueue</code> 里 <code>next()</code> 方法的 for 死循环内，获取 <code>mIdleHandlers</code> 的数量 <code>pendingIdleHandlerCount</code>；</li><li>通过 <code>mMessages == null || now &lt; mMessages.when</code> 判断当前消息队列为空或者目前没有需要执行的消息时，给 <code>pendingIdleHandlerCount</code> 赋值；</li><li>当数量大于 0，遍历取出数组内的 <code>IdleHandler</code>，执行 <code>queueIdle()</code> ；</li><li>返回值为 <code>false</code> 时，主动移除监听 <code>mIdleHandlers.remove(idler)</code>；</li></ol></li><li><p><strong>使用场景</strong>：</p><ul><li>如果启动的 <code>Activity</code>、<code>Fragment</code>、<code>Dialog</code> 内含有大量数据和视图的加载，导致首次打开时动画切换卡顿或者一瞬间白屏，可将部分加载逻辑放到 <code>queueIdle()</code> 内处理。例如引导图的加载和弹窗提示等；</li><li>系统源码中 <code>ActivityThread</code> 的 <code>GcIdler</code>，在某些场景等待消息队列暂时空闲时会尝试执行 GC 操作；</li><li>系统源码中  <code>ActivityThread</code> 的 <code>Idler</code>，在 <code>handleResumeActivity()</code> 方法内会注册 <code>Idler()</code>，等待<code>handleResumeActivity</code> 后视图绘制完成，消息队列暂时空闲时再调用 <code>AMS</code> 的 <code>activityIdle</code> 方法，检查页面的生命周期状态，触发 <code>activity</code> 的 <code>stop</code> 生命周期等。这也是为什么我们 <code>BActivity</code> 跳转 <code>CActivity</code> 时，<code>BActivity</code> 生命周期的 <code>onStop()</code> 会在 <code>CActivity</code> 的 <code>onResume()</code> 后。</li><li>一些第三方框架 <code>Glide</code> 和 <code>LeakCanary</code> 等也使用到 <code>IdleHandler</code>；</li></ul></li></ul><h3 id="7、什么是HandlerThread？"><a href="#7、什么是HandlerThread？" class="headerlink" title="7、什么是HandlerThread？"></a>7、什么是HandlerThread？</h3><ul><li>HandlerThread本质上是一个线程类，它继承了Thread；</li><li>HandlerThread有自己的内部Looper对象，可以进行looper循环；</li><li>通过获取HandlerThread的looper对象传递给Handler对象，可以在handleMessage方法中执行异步任务；</li><li>创建HandlerThread后必须先调用HandlerThread.start()方法，Thread会先调用run方法，创建Looper对象。<br>HandlerThread其实就是在一个子线程内部自己创建并管理了一个Looper。</li><li>如果经常要开启线程，接着又是销毁线程，这是很耗性能的，HandlerThread 很好的解决了这个问题</li><li>HandlerThread 由于异步操作是放在 Handler 的消息队列中的，所以是串行的，但只适合并发量较少的耗时操作</li></ul><h3 id="8、进程间的通信方式有哪些？"><a href="#8、进程间的通信方式有哪些？" class="headerlink" title="8、进程间的通信方式有哪些？"></a>8、进程间的通信方式有哪些？</h3><ul><li><p><strong>Bundle&#x2F;Intent传递数据</strong>：</p><p>可传递基本类型，String，实现了Serializable或Parcellable接口的数据结构。Serializable是Java的序列化方法，Parcellable是Android的序列化方法，前者代码量少（仅一句），但I&#x2F;O开销较大，一般用于输出到磁盘或网卡；后者实现代码多，效率高，一般用户内存间序列化和反序列化传输。</p></li><li><p><strong>文件共享</strong>：</p><p>对同一个文件先后写读，从而实现传输，Linux机制下，可以对文件并发写，所以要注意同步。顺便一提，Windows下不支持并发读或写。</p></li><li><p><strong>Messenger</strong>：</p><p>Messenger是基于AIDL实现的，服务端（被动方）提供一个Service来处理客户端（主动方）连接，维护一个Handler来创建Messenger，在onBind时返回Messenger的binder。</p></li><li><p><strong>AIDL</strong>：</p><p>AIDL通过定义服务端暴露的接口，以提供给客户端来调用，AIDL使服务器可以并行处理，而Messenger封装了AIDL之后只能串行运行，所以Messenger一般用作消息传递。通过编写aidl文件来设计想要暴露的接口，编译后会自动生成响应的java文件，服务器将接口的具体实现写在Stub中，用iBinder对象传递给客户端，客户端bindService的时候，用asInterface的形式将iBinder还原成接口，再调用其中的方法。</p></li><li><p><strong>ContentProvider</strong>：</p><p>系统四大组件之一，底层也是Binder实现，主要用来为其他APP提供数据，可以说天生就是为进程通信而生的。自己实现一个ContentProvider需要实现6个方法，其中onCreate是主线程中回调的，其他方法是运行在Binder之中的。自定义的ContentProvider注册时要提供authorities属性，应用需要访问的时候将属性包装成Uri.parse(“content:&#x2F;&#x2F;authorities”)。还可以设置permission，readPermission，writePermission来设置权限。 ContentProvider有query，delete，insert等方法，看起来貌似是一个数据库管理类，但其实可以用文件，内存数据等等一切来充当数据源，query返回的是一个Cursor，可以自定义继承AbstractCursor的类来实现。</p></li><li><p><strong>Socket</strong></p></li></ul><h3 id="9、ANR发生的原因及其解决办法"><a href="#9、ANR发生的原因及其解决办法" class="headerlink" title="9、ANR发生的原因及其解决办法"></a>9、ANR发生的原因及其解决办法</h3><p>ANR的全称是application not responding，是指应用程序未响应，Android系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成ANR。一般地，这时往往会弹出一个提示框，告知用户当前xxx未响应，用户可选择继续等待或者Force Close。</p><p>首先ANR的发生是有条件限制的，分为以下三点：</p><ul><li>只有主线程才会产生ANR，主线程就是UI线程；</li><li>必须发生某些输入事件或特定操作，比如按键或触屏等输入事件，在BroadcastReceiver或Service的各个生命周期调用函数；</li><li>上述事件响应超时，不同的context规定的上限时间不同<ol><li>主线程对输入事件5秒内没有处理完毕</li><li>主线程在执行BroadcastReceiver的onReceive()函数时10秒内没有处理完毕</li><li>主线程在前台Service的各个生命周期函数时20秒内没有处理完毕（后台Service 200s）</li></ol></li></ul><p>那么导致ANR的根本原因是什么呢？简单的总结有以下两点：</p><ul><li>主线程执行了<strong>耗时操作</strong>，比如数据库操作或网络编程，I&#x2F;O操作</li><li>其他进程（就是其他程序）占用CPU导致本进程<strong>得不到CPU时间片</strong>，比如其他进程的频繁读写操作可能会导致这个问题</li></ul><p>那么如何避免ANR的发生呢或者说ANR的解决办法是什么呢？</p><ul><li>避免在主线程执行耗时操作，所有耗时操作应新开一个子线程完成，然后再在主线程更新UI</li><li>BroadcastReceiver要执行耗时操作时应启动一个service，将耗时操作交给service来完成</li><li>避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广播时需要向用户展示什么，你应该使用Notification Manager来实现</li></ul><h2 id="四、项目架构"><a href="#四、项目架构" class="headerlink" title="四、项目架构"></a>四、项目架构</h2><h3 id="1、MVC"><a href="#1、MVC" class="headerlink" title="1、MVC"></a>1、MVC</h3><p>M——模型层（Model）负责处理数据的加载或者存储</p><p>V——视图层（View）负责界面数据的展示，与用户进行交互</p><p>C——控制器层（Controller）负责逻辑业务的处理</p><img src="C:\Users\zzp\AppData\Roaming\Typora\typora-user-images\image-20230312230131742.png" alt="image-20230312230131742" style="zoom:80%;" /><p>在MVC模式中，View层可以直接访问Model层和Controller层，所以View层包含Model层信息和Controller层的业务逻辑处理</p><ul><li><p>优点：</p><ul><li>耦合性低，生命周期成本低，部署快，可维护性高，适用于快速开发的小型项目</li></ul></li><li><p>缺点：</p><ul><li>不适合大型，中等项目，View层Controller层连接过于紧密</li><li>View层对Model层的访问效率低</li><li>一般的高级UI页面工具和构造器不支持MVC模式</li></ul></li><li><p>注意：</p><ul><li>Activity和Fragment既有View的性质，又具有Controller的性质，导致Acyivity和Fragment很重</li><li>MVC中View层与Model层直接交互，所以Activity和Fragment与Model的耦合性很高</li></ul></li></ul><h3 id="2、MVP"><a href="#2、MVP" class="headerlink" title="2、MVP"></a>2、MVP</h3><p>M——数据层（Model）负责对数据的存取操作，例如对数据库的读写，网络的数据的请求等</p><p>V——视图层（View）负责对数据的展示，提供友好的界面与用户进行交互，Android通常将Activity或者Fragment作为View层</p><p>P——控制器层（Presenter）连接View层与Model层的桥梁并对业务逻辑进行处理</p><img src="C:\Users\zzp\AppData\Roaming\Typora\typora-user-images\image-20230312230639460.png" alt="image-20230312230639460" style="zoom:80%;" /><p> <strong>MVP执行流程：</strong></p><ul><li>View层收到用户的操作</li><li>View层把用户的操作交给Presenter</li><li>Presenter直接操作Model层进行业务逻辑处理</li><li>Model层处理完毕后，通知Presenter</li><li>Presenter收到通知后，去更新View层</li></ul><p>在MVP模式中，Model与View无法直接进行交互，所以Presenter层会从Model层获得数据，适当处理后交给View层进行显示，Presenter层将View层和Model层进行隔离，使View和Model之间不存在耦合，同时将业务逻辑从View层剥离</p><ul><li><p>优点：</p><ul><li>模型与视图完全分离，修改View而不Model</li><li>可以更高效的使用Model，所有的交互都发生在——Presenter内部</li><li>将一个Presenter用于多个视图，而不需要改变Presenter的逻辑，View变化比Model变化频繁</li><li>逻辑结构清晰，View层代码不再臃肿</li></ul></li><li><p>缺点：</p><ul><li>MVP模式基于接口设计，会增加很多类，代码逻辑虽然清晰，但代码量庞大</li><li>MVP适用于中小型项目，大型项目慎用</li></ul></li><li><p>MVC和MVP的主要区别：</p><ul><li>MVP中View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互</li><li>MVC中Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个View</li><li>MVP中Presenter与View的交互是通过接口来进行的，更有利于添加单元测试。</li><li>MVC中View可以与Model直接交互，通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑</li></ul></li><li><p>注意：</p><ul><li>MVP中将这三层分别抽象到各自的接口当中，通过接口将层次之间进行隔离</li><li>Presenter对View和Model的相互依赖也是依赖于各自的接口，符合了接口隔离原则</li><li>Presenter层中包含了一个View接口，并且依赖于Model接口，从而将Model层与View层联系在一起</li><li>View层会持有一个Presenter成员变量并且只保留对Presenter接口的调用，具体业务逻辑全部交由Presenter接口实现类中处理</li></ul></li></ul><h3 id="3、MVVM"><a href="#3、MVVM" class="headerlink" title="3、MVVM"></a>3、MVVM</h3><p>M——Model（模型）实体模型，定义实体类，获取业务数据模型，如通过数据库或者网络来操作数据等</p><p>V——View（视图）布局文件(XML），主要进行控件的初始化设置</p><p>VM——ViewModel（控制器）：连接 View 与 Model 的中间桥梁，ViewModel 与 Model 直接交互，通过DataBinding将数据变化反应给View<br><img src="C:\Users\zzp\AppData\Roaming\Typora\typora-user-images\image-20230312231248908.png" alt="image-20230312231248908"></p><p><strong>注：</strong>ViewModel可以理解为View与Presenter的合成体</p><p><strong>优点：</strong></p><ul><li>低耦合<ul><li>MVVM 模式中，数据处理逻辑是独立于 UI 层的</li><li>ViewModel 只负责提供数据和处理数据，不会持有 View 层的引用</li><li>View 层只负责对数据变化的监听，不会处理任何跟数据相关的逻辑</li><li>View 层的 UI 发生变化时，也不需要像 MVP 模式那样修改对应接口和方法实现，一般情况下ViewModel 不需要做太多的改动</li></ul></li><li>数据驱动<ul><li>UI 的展现是依赖于数据的，数据的变化会自然的引发 UI 的变化，而 UI 的改变也会使数据 Model 进行对应的更新</li><li>ViewModel 只需要处理数据，而 View 层只需要监听并使用数据进行 UI 更新</li></ul></li><li>异步线程更新Model<ul><li>Model 数据可以在异步线程中发生变化，此时调用者不需要做额外的处理</li><li>数据绑定框架会将异步线程中数据的变化通知到 UI 线程中交给 View去更新</li></ul></li><li>方便协作<ul><li>View 层和逻辑层几乎没有耦合，在团队协作的过程中，可以一个人负责 UI，一个人负责数据处理。并行开发，保证开发进度</li></ul></li><li>易于单元测试<ul><li>ViewModel 层只负责处理数据，在进行单元测试时，测试不需要构造一个 fragment&#x2F;Activity&#x2F;TextView 等来进行数据层的测试</li><li>View 层也一样，只需要输入指定格式的数据即可进行测试，而且两者相互独立，不会互相影响</li></ul></li><li>数据复用<ul><li>ViewModel 层对数据的获取和处理逻辑，尤其是使用 Repository 模式时，获取数据的逻辑完全是可以复用的</li><li>开发者可以在不同的模块，多次方便的获取同一份来源的数据</li><li>同样的一份数据，在版本功能迭代时，逻辑层不需要改变，只需要改变 View 层即可</li></ul></li></ul><h2 id="五、Kotlin"><a href="#五、Kotlin" class="headerlink" title="五、Kotlin"></a>五、Kotlin</h2><h3 id="1、扩展函数原理"><a href="#1、扩展函数原理" class="headerlink" title="1、扩展函数原理"></a>1、扩展函数原理</h3><p>扩展函数实际上就是一个对应 Java 中的静态函数，这个静态函数参数为接收者类型的对象，然后利用这个对象就可以访问这个类中的成员属性和方法了，并且最后返回一个这个接收者类型对象本身。这样在外部感觉和使用类的成员函数是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个类名就是顶层文件名+“Kt”后缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExtendsionTextViewKt</span> &#123;</span><br><span class="line">   <span class="comment">// 扩展函数 isBold 对应实际上是 Java 中的静态函数，并且传入一个接收者类型对象作为参数</span></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TextView <span class="title function_">isBold</span><span class="params">(<span class="meta">@NotNull</span> TextView $receiver)</span> &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull($receiver, <span class="string">&quot;$receiver&quot;</span>);</span><br><span class="line">      $receiver.getPaint().setFakeBoldText(<span class="literal">true</span>); <span class="comment">// 设置加粗</span></span><br><span class="line">      <span class="keyword">return</span> $receiver; <span class="comment">// 最后返回这个接收者对象自身，以致于我们在Kotlin中完全可以使用 this 替代接收者对象或者直接不写。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、协程原理"><a href="#2、协程原理" class="headerlink" title="2、协程原理"></a>2、协程原理</h3>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面经</title>
      <link href="/2024/05/21/Java%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/05/21/Java%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-面经"><a href="#Java-面经" class="headerlink" title="Java 面经"></a>Java 面经</h1><h2 id="一、Java-基础"><a href="#一、Java-基础" class="headerlink" title="一、Java  基础"></a>一、Java  基础</h2><h3 id="1、final-关键字的作用"><a href="#1、final-关键字的作用" class="headerlink" title="1、final 关键字的作用"></a>1、final 关键字的作用</h3><ul><li>修饰引用：该引用为常量，其值无法修改</li><li>修饰方法：该方法为最终方法，无法被子类重写</li><li>修饰类：该类为最终类，无法被继承</li></ul><h3 id="2、String、StringBuffer、StringBuilder-的区别"><a href="#2、String、StringBuffer、StringBuilder-的区别" class="headerlink" title="2、String、StringBuffer、StringBuilder 的区别"></a>2、String、StringBuffer、StringBuilder 的区别</h3><ul><li>String：值是不可变的，这就导致每次对String的操作都会产生新的String对象，效率低下且浪费内存</li><li>StringBuffer：值可变且线程安全</li><li>StringBuilder：值可变但线程不安全，速度较StringBuffer更快</li></ul><h3 id="3、String为什么要设计成不可变的"><a href="#3、String为什么要设计成不可变的" class="headerlink" title="3、String为什么要设计成不可变的"></a>3、String为什么要设计成不可变的</h3><ul><li>防止被篡改，保证信息数据的安全性</li><li>不变的对象和值是线程安全的</li><li>哈希值的唯一性来提高性能</li><li>提高常量池的可用性</li></ul><h3 id="4、抽象类和接口的区别"><a href="#4、抽象类和接口的区别" class="headerlink" title="4、抽象类和接口的区别"></a>4、抽象类和接口的区别</h3><ul><li>抽象类是半抽象的，有构造方法，只允许出现常量和抽象方法。类和类之间只能单继承，一个抽象类只能继承一个类（单继承），多个功能的集成部分，可用抽象类（抽象类提供简单方法）</li><li>接口是完全抽象的，没有构造方法，接口和接口之间支持多继承，一个类可以同时实现多个接口</li></ul><h3 id="5、static-关键字的作用"><a href="#5、static-关键字的作用" class="headerlink" title="5、static 关键字的作用"></a>5、static 关键字的作用</h3><ul><li>修饰方法：静态方法不依赖于任何对象就可以进行访问，在静态方法中不能访问类的非静态成员变量和非静态成员方法</li><li>修饰变量：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化</li><li>修饰代码块：在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次</li></ul><h3 id="6、多态是什么"><a href="#6、多态是什么" class="headerlink" title="6、多态是什么"></a>6、多态是什么</h3><ul><li>多态分为两种：<ul><li>编译时多态(设计时多态)：方法重载</li><li>运行时多态：JAVA运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态</li></ul></li><li>多态存在的三个必要条件：<ul><li>要有继承(包括接口的实现)</li><li>要有重写</li><li>父类引用指向子类对象（向上转型）</li></ul></li></ul><h3 id="7、Exception-和-Error-的区别"><a href="#7、Exception-和-Error-的区别" class="headerlink" title="7、Exception 和 Error 的区别"></a>7、Exception 和 Error 的区别</h3><ul><li>Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应的处理</li><li>Error 是指在正常情况下，不大可能出现的情况，绝大部分 Error 都会使程序处于非正常、不可恢复的状态。既然是非正常，所以不便于也不需要捕获，常见的 OutOfMemoryError 就是 Error 的子类</li></ul><h3 id="8、什么是反射机制？反射机制的应用场景有哪些？"><a href="#8、什么是反射机制？反射机制的应用场景有哪些？" class="headerlink" title="8、什么是反射机制？反射机制的应用场景有哪些？"></a>8、什么是反射机制？反射机制的应用场景有哪些？</h3><ul><li>对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在运行时动态的获取信息以及动态调用对象的方法的功能称为Java 的反射机制</li><li>应用场景：<ul><li>工厂模式</li><li>注解</li><li>json解析</li><li>动态代理</li></ul></li></ul><h3 id="9、为什么重写-equals-还要重写-hashCode-？"><a href="#9、为什么重写-equals-还要重写-hashCode-？" class="headerlink" title="9、为什么重写 equals 还要重写 hashCode ？"></a>9、为什么重写 equals 还要重写 hashCode ？</h3><p>hashCode 和 equals 两个方法是用来协同判断两个对象是否相等的，采用这种方式的原因是可以提高程序插入和查询的速度，如果在重写 equals 时，不重写 hashCode，就会导致在某些场景下，例如将两个相等的自定义对象存储在 Set 集合时，就会出现程序执行的异常，为了保证程序的正常执行，所以我们就需要在重写 equals 时，也一并重写 hashCode 方法才行</p><h3 id="10、Java-泛型类型擦除和其局限性"><a href="#10、Java-泛型类型擦除和其局限性" class="headerlink" title="10、Java 泛型类型擦除和其局限性"></a>10、Java 泛型类型擦除和其局限性</h3><ul><li><p>Java的泛型是伪泛型，Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程称为类型擦除</p></li><li><p>局限性：</p><ul><li><p><strong>运行时类型查询只适用于原始类型</strong></p><p>查询一个对象是否属于某个泛型类型时，倘若使用 <code>instanceof</code> 会得到一个编译器错误， 如果使用强制类型转换会得到一个警告</p></li><li><p><strong>不能用基本类型实例化类型参数</strong></p><p>不能用类型参数代替基本类型。因此， 没有 <code>Pair&lt;int&gt;</code>, 只 有 <code>Pair&lt;Integer&gt;</code>。 当然,其原因是类型擦除。擦除之后， Pair 类含有 Object 类型的域， 而 Object 不能存储 int值</p></li><li><p><strong>不能实例化类型变量</strong></p><p>不能使用像 new T(…)、 newT[…] 或 T.class 这样的表达式中的类型变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T singlelnstance;        <span class="comment">// Error</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">getSinglelnstance</span><span class="params">()</span> &#123;   <span class="comment">// Error</span></span><br><span class="line">        <span class="keyword">if</span> (singleinstance == <span class="literal">null</span>) construct <span class="keyword">new</span> <span class="title class_">instance</span> of T</span><br><span class="line">        <span class="keyword">return</span> singlelnstance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>不能抛出或捕获泛型类的实例</strong></p><p>实际上， 甚至泛型类扩展 <strong>Throwable</strong> 都是不合法的；</p><p><strong>catch</strong> 子句中不能使用类型变量。例如， 以下方法将不能编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(Class&lt;T&gt; t)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">do</span> work</span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;     <span class="comment">// Error can &#x27;t catch type variable</span></span><br><span class="line">        Logger,global.info(...) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>不能创建参数化类型的数组</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="11、Java中引用类型的区别，具体的使用场景"><a href="#11、Java中引用类型的区别，具体的使用场景" class="headerlink" title="11、Java中引用类型的区别，具体的使用场景"></a>11、Java中引用类型的区别，具体的使用场景</h3><ul><li><p><strong>强引用：</strong> 强引用指的是通过 new 对象创建的引用。</p><ul><li>正常创建的对象，只要引用存在，永远不会被GC回收，即使OOM</li><li>如果要中断强引用和某个对象的关联，为其赋值null，这样GC就会在合适的时候回收对象</li><li>Vector类的clear()方法就是通过赋值null进行清除</li></ul></li><li><p><strong>软引用：</strong> 软引用是通过 SoftRefrence 实现的，它的生命周期比强引用短，在内存不足，抛出 OOM 之前，垃圾回收器会回收软引用引用的对象。软引用常见的使用场景是存储一些内存敏感的缓存，当内存不足时会被回收。</p><ul><li>在内存足够的情况下进行缓存，提升速度，内存不足时JVM自动回收</li><li>可以和引用队列ReferenceQueue联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中</li></ul></li><li><p><strong>弱引用：</strong> 弱引用是通过 WeakRefrence 实现的，它的生命周期比软引用还短，GC 只要扫描到弱引用的对象就会回收。弱引用常见的使用场景也是存储一些内存敏感的缓存。</p><ul><li>ThreadLocalMap防止内存泄漏 </li><li>监控对象是否将要被回收</li></ul></li><li><p><strong>虚引用：</strong> 虚引用是通过 FanttomRefrence 实现的，它的生命周期最短，随时可能被回收。如果一个对象只被虚引用引用，我们无法通过虚引用来访问这个对象的任何属性和方法。它的作用仅仅是保证对象在 finalize 后，做某些事情。虚引用常见的使用场景是跟踪对象被垃圾回收的活动，当一个虚引用关联的对象被垃圾回收器回收之前会收到一条系统通知。</p><ul><li>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动</li></ul></li></ul><h3 id="12、单例模式"><a href="#12、单例模式" class="headerlink" title="12、单例模式"></a>12、单例模式</h3><ul><li>双重检查单例模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一次校验</strong>：</p><p>也就是第一个if（singleton&#x3D;&#x3D;null），这个是为了代码提高代码执行效率，由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用getInstance方法就不必要进入同步代码块，不用竞争锁。直接返回前面创建的实例即可。</p><p><strong>第二次校验</strong>：</p><p>也就是第二个if（singleton&#x3D;&#x3D;null），这个校验是防止二次创建实例，假如有一种情况，当singleton还未被创建时，线程t1调用getInstance方法，由于第一次判断singleton&#x3D;&#x3D;null，此时线程t1准备继续执行，但是由于资源被线程t2抢占了，此时t2页调用getInstance方法，同样的，由于singleton并没有实例化，t2同样可以通过第一个if，然后继续往下执行，同步代码块，第二个if也通过，然后t2线程创建了一个实例singleton。此时t2线程完成任务，资源又回到t1线程，t1此时也进入同步代码块，如果没有这个第二个if，那么，t1就也会创建一个singleton实例，那么，就会出现创建多个实例的情况，但是加上第二个if，就可以完全避免这个多线程导致多次创建实例的问题。</p><ul><li>静态内部类单例模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在内部类被加载和初始化时，才创建INSTANCE</span></span><br><span class="line"><span class="comment">静态类不会自动随着外部类的加载和初始化而初始化的，它是要单独去加载和初始化的。</span></span><br><span class="line"><span class="comment">因为是在内部类加载和初始化时，创建的，因此是线程安全的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13、类加载过程"><a href="#13、类加载过程" class="headerlink" title="13、类加载过程"></a>13、类加载过程</h3><p>Java 中类加载分为 3 个步骤：加载、链接、初始化。</p><ul><li><p><strong>加载</strong>： 由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例。数据源可以是 Jar 文件、Class 文件等等。如果数据的格式并不是 ClassFile 的结构，则会报 ClassFormatError</p></li><li><p><strong>链接</strong>：链接是类加载的核心部分，这一步分为 3 个步骤：验证、准备、解析</p><ul><li><strong>验证</strong>： 验证是保证JVM安全的重要步骤。JVM需要校验字节信息是否符合规范，避免恶意信息和不规范数据危害JVM运行安全。如果验证出错，则会报VerifyError<ul><li>格式验证：验证是否符合class文件规范。</li><li>语义验证：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）</li><li>操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）</li></ul></li><li><strong>准备</strong>： 这一步会创建静态变量，并为静态变量开辟内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内），被final修饰的static变量（常量），会直接赋值</li><li><strong>解析</strong>： 这一步会将符号引用替换为直接引用。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li></ul></li><li><p><strong>初始化（先父后子）</strong>： 初始化会为静态变量赋值，并执行静态代码块中的逻辑</p><ul><li><p>如果是多线程需要同时初始化一个类，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。</p><p>因为子类存在对父类的依赖，所以类的加载顺序是先加载父类后加载子类，初始化也一样。不过，父类初始化时，子类静态变量的值也有有的，是默认值。</p><img src="C:\Users\zzp\AppData\Roaming\Typora\typora-user-images\image-20230315205319406.png" alt="image-20230315205319406" style="zoom:80%;" /></li></ul></li></ul><h3 id="14、双亲委派模型"><a href="#14、双亲委派模型" class="headerlink" title="14、双亲委派模型"></a>14、双亲委派模型</h3><p>类加载器大致分为3类：启动类加载器、扩展类加载器、应用程序类加载器。</p><ul><li>启动类加载器主要加载 <code>jre/lib</code>下的<code>jar</code>文件。</li><li>扩展类加载器主要加载 <code>jre/lib/ext</code> 下的<code>jar</code>文件。</li><li>应用程序类加载器主要加载 <code>classpath</code> 下的文件。</li></ul><p>所谓的双亲委派模型就是当加载一个类时，会优先使用父类加载器加载，当父类加载器无法加载时才会使用子类加载器去加载。这么做的目的是为了避免类的重复加载。</p><h3 id="15、new一个对象要经历哪些过程"><a href="#15、new一个对象要经历哪些过程" class="headerlink" title="15、new一个对象要经历哪些过程"></a>15、new一个对象要经历哪些过程</h3><ul><li><p>首先Java在new一个对象的时候，会先查看对象所属的类有没有被加载到内存，如果没有的话，就会先通过类的全限定名将对象所属的.class文件加载到内存中。加载并初始化类完成后，再进行对象的创建工作。</p></li><li><p>初始化类完成后，就是创建对象</p><ol><li><p><strong>在堆区分配对象需要的内存</strong></p><p>分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量。</p></li><li><p><strong>对所有实例变量赋默认值</strong></p><p>将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值。</p></li><li><p><strong>执行实例初始化代码</strong></p><p>初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法。</p></li><li><p>如果有类似于<code>Child c = new Child()</code>形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它需要注意的是，每个子类对象持有父类对象的引用，可在内部通过super关键字来调用父类对象，但在外部不可访问。</p></li><li><p>补充：通过实例引用调用实例方法的时候，先从方法区中对象的实际类型信息找，找不到的话再去父类类型信息中找。</p><p>如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为虚方法表的方法来优化调用的效率。</p><p>所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。</p></li></ol></li></ul><h2 id="二、Java-数据结构"><a href="#二、Java-数据结构" class="headerlink" title="二、Java 数据结构"></a>二、Java 数据结构</h2><h3 id="1、HashMap-和-Hashtable-的区别"><a href="#1、HashMap-和-Hashtable-的区别" class="headerlink" title="1、HashMap 和 Hashtable 的区别"></a>1、HashMap 和 Hashtable 的区别</h3><ul><li>HashMap是线程不安全的，效率高；Hashtable是线程安全的，效率低；</li><li>HashMap可以存储null键和null值；Hashtable不可以存储null键和null值；</li></ul><h3 id="2、HashMap-底层原理"><a href="#2、HashMap-底层原理" class="headerlink" title="2、HashMap 底层原理"></a>2、HashMap 底层原理</h3><ul><li>HashMap由数组（键值对entry组成的数组主干）+ 链表（元素太多时为解决哈希冲突数组的一个元素上多个entry组成的链表）+ 红黑树（当链表的元素个数达到8链表存储改为红黑树存储）进行数据的存储</li><li>在JDK1.7之前，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个数组中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</li></ul><h3 id="3、HashMap-的扩容过程"><a href="#3、HashMap-的扩容过程" class="headerlink" title="3、HashMap 的扩容过程"></a>3、HashMap 的扩容过程</h3><p>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</p><h3 id="4、为什么-HashMap-使用红黑树而不用二叉平衡树（AVL）"><a href="#4、为什么-HashMap-使用红黑树而不用二叉平衡树（AVL）" class="headerlink" title="4、为什么 HashMap 使用红黑树而不用二叉平衡树（AVL）"></a>4、为什么 HashMap 使用红黑树而不用二叉平衡树（AVL）</h3><ul><li>红黑树虽然不是严格的平衡树，但是其依旧是平衡树，查找效率是 **O(logn)**；AVL也是 <strong>O(logn)</strong></li><li>红黑树舍去了严格的平衡，使其插入，删除，查找的效率稳定在 **O(logn)**；反观 AVL 树，查找没问题 **O(logn)**，但是为了保证高度平衡，动态插入和删除的代价也随之增加，综合效率肯定达不到 <strong>O(logn)</strong></li><li>在进行大量插入，删除操作时，红黑树更优一些</li></ul><h3 id="5、TreeMap-底层原理"><a href="#5、TreeMap-底层原理" class="headerlink" title="5、TreeMap 底层原理"></a>5、TreeMap 底层原理</h3><p>TreeMap底层通过红黑树实现，可保证在**O(logn)**完成get、put和remove操作，效率很高</p><h3 id="6、Hashtable-怎么保证线程安全的"><a href="#6、Hashtable-怎么保证线程安全的" class="headerlink" title="6、Hashtable 怎么保证线程安全的"></a>6、Hashtable 怎么保证线程安全的</h3><p>使用synchronized关键字修饰public方法保证线程安全</p><h3 id="7、ConcurrentHashMap-原理"><a href="#7、ConcurrentHashMap-原理" class="headerlink" title="7、ConcurrentHashMap 原理"></a>7、ConcurrentHashMap 原理</h3><ul><li><p>在 JDK7 中，ConcurrentHashMap 使用“分段锁”机制实现线程安全，数据结构可以看成是”Segment数组+HashEntry数组+链表”，一个 ConcurrentHashMap 实例中包含若干个 Segment 实例组成的数组，每个 Segment 实例又包含由若干个桶，每个桶中都是由若干个 HashEntry 对象链接起来的链表。因为<strong>Segment 类继承 ReentrantLock 类</strong>，所以能充当锁的角色，通过 segment 段将 ConcurrentHashMap 划分为不同的部分，就可以使用不同的锁来控制对哈希表不同部分的修改，从而允许多个写操作并发进行，默认支持 16 个线程执行并发写操作，及任意数量线程的读操作。</p><img src="C:\Users\zzp\AppData\Roaming\Typora\typora-user-images\image-20230313113723907.png" alt="image-20230313113723907" style="zoom:80%;" /></li><li><p>put过程：</p><ol><li>对key进行第1次hash，通过hash值确定Segment的位置</li><li>在Segment内进行操作，获取锁</li><li>获取当前Segment的HashEntry数组后对key进行第2次hash，通过hash值确定在HashEntry数组的索引位置（头部）</li><li>通过继承ReentrantLock的tryLock方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock方法去获取锁，超过指定次数就挂起，等待唤醒</li><li>然后对当前索引的HashEntry链进行遍历，如果有重复的key，则替换；如果没有重复的，则插入到链头</li><li>释放锁</li></ol></li><li><p>get操作</p><p>和put操作类似，也是要两次hash。但是get操作的ConcurrentHashMap不需要加锁，原因是存储元素都标记了volatile</p></li><li><p>size操作</p><ul><li>size操作就是遍历两次所有的Segments，每次记录Segment的modCount值，然后将两次的modCount进行比较</li><li>如果相同，则表示期间没有发生过写入操作，就将原先遍历的结果返回。<br>如果经判断发现两次统计出的modCount并不一致，要全部Segment加锁来进行count的获取和统计。在此期间每个Segement都被锁住，无法进行其他操作，统计出的count自然很准确。</li></ul></li></ul><h3 id="8、ConcurrentHashMap-读操作为什么不需要加锁？"><a href="#8、ConcurrentHashMap-读操作为什么不需要加锁？" class="headerlink" title="8、ConcurrentHashMap 读操作为什么不需要加锁？"></a>8、ConcurrentHashMap 读操作为什么不需要加锁？</h3><ul><li>在 HashEntry 类中，key，hash 和 next 域都被声明为 final 的，value 域被 volatile 所修饰，因此 HashEntry 对象几乎是不可变的，通过 HashEntry 对象的不变性来降低读操作对加锁的需求<ul><li>next 域被声明为 final，意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改 next 引用值，因此所有的节点的修改只能从头部开始。但是对于 remove 操作，需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。</li></ul></li><li>用 volatile 变量协调读写线程间的内存可见性；</li><li>若读时发生指令重排序现象（也就是读到 value 域的值为 null 的时候），则加锁重读；</li></ul><h3 id="9、怎么解决hash冲突"><a href="#9、怎么解决hash冲突" class="headerlink" title="9、怎么解决hash冲突"></a>9、怎么解决hash冲突</h3><ul><li><p><strong>链地址法</strong>：对于相同的哈希值，使用链表进行连接。（<strong>HashMap使用此法</strong>）</p><ul><li><p>优点：</p><ol><li>处理冲突简单，无堆积现象。即非同义词决不会发生冲突，因此平均查找长度较短。</li><li>适合总数经常变化的情况。（因为拉链法中各链表上的结点空间是动态申请的）</li><li>占空间小。装填因子可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计。</li><li>删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</li></ol></li><li><p>缺点</p><ol><li>查询时效率较低。（存储是动态的，查询时跳转需要更多的时间）</li><li>在key-value可以预知，以及没有后续增改操作时候，开放定址法性能优于链地址法。</li><li>不容易序列化。</li></ol></li></ul></li><li><p><strong>再哈希法</strong>：提供多个哈希函数，如果第一个哈希函数计算出来的key的哈希值冲突了，则使用第二个哈希函数计算key的哈希值。</p><ul><li>优点：不易产生聚集</li><li>缺点：增加了计算时间</li></ul></li><li><p><strong>建立公共溢出区</strong>：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p></li><li><p><strong>开放定址法</strong>：当关键字key的哈希地址p &#x3D;H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，若p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</p></li></ul><h2 id="三、Java-多线程"><a href="#三、Java-多线程" class="headerlink" title="三、Java 多线程"></a>三、Java 多线程</h2><h3 id="1、进程和线程的区别"><a href="#1、进程和线程的区别" class="headerlink" title="1、进程和线程的区别"></a>1、进程和线程的区别</h3><ul><li>根本区别：进程是操作系统进行资源分配的最小单元，是操作系统对一个正在运行的程序的一种抽象，可以把进程看作程序运行的一次运行过程；线程是操作系统进行运算调度的最小单元</li><li>进程中包含了线程，线程属于进程</li><li>进程的创建、销毁和切换的开销都远大于线程</li><li>每个进程有自己的内存和资源，一个进程中的线程会共享这些内存和资源</li><li>子进程无法影响父进程，而子线程可以影响父线程，如果主线程发生异常会影响其所在进程和子线程</li><li>进程的CPU利用率较低，因为上下文切换开销较大，而线程的CPU的利用率较高，上下文的切换速度快</li><li>进程的操纵者一般是操作系统，线程的操纵者一般是编程人员</li></ul><h3 id="2、什么是上下文切换"><a href="#2、什么是上下文切换" class="headerlink" title="2、什么是上下文切换"></a>2、什么是上下文切换</h3><ul><li>即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。 CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个 任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这 个任务的状态。所以<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</li></ul><h3 id="3、并发和并行的区别"><a href="#3、并发和并行的区别" class="headerlink" title="3、并发和并行的区别"></a>3、并发和并行的区别</h3><ul><li>并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行</li><li>并行：当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行</li></ul><h3 id="4、线程有哪几种状态"><a href="#4、线程有哪几种状态" class="headerlink" title="4、线程有哪几种状态"></a>4、线程有哪几种状态</h3><ul><li>**初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法</li><li>**运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）</li><li>**阻塞(BLOCKED)**：表示线程阻塞于锁</li><li>**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）</li><li>**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回</li><li>**终止(TERMINATED)**：表示该线程已经执行完毕</li></ul><h3 id="5、volatile-关键字的作用和原理"><a href="#5、volatile-关键字的作用和原理" class="headerlink" title="5、volatile 关键字的作用和原理"></a>5、volatile 关键字的作用和原理</h3><ul><li><p>禁止了指令重排（指令重排是指：为了提高性能，编译器和和处理器通常会对指令进行指令重排序）</p></li><li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这个新值对其他线程是立即可见的</p><ul><li>这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取</li></ul></li><li><p><strong>不保证原子性</strong></p></li><li><p>原理：volatile的原理是在生成的汇编代码中多了一个lock前缀指令，这个前缀指令相当于一个内存屏障，这个内存屏障有3个作用：</p><ul><li>确保指令重排的时候不会把屏障后的指令排在屏障前，确保不会把屏障前的指令排在屏障后。</li><li>将当前处理器缓存行的数据写回到系统内存</li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存失效</li></ul></li></ul><h3 id="6、synchronized-关键字的作用"><a href="#6、synchronized-关键字的作用" class="headerlink" title="6、synchronized 关键字的作用"></a>6、synchronized 关键字的作用</h3><ul><li>修饰实例方法：作用于<strong>当前对象实例</strong>加锁，进入同步代码前要获得当前对象实例的锁</li><li>修饰静态方法：也就是给当前类（即<strong>XXX.class</strong>对象）加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized  方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</li><li>修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</li><li>synchronized <strong>可重入性</strong>（当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功）</li></ul><h3 id="7、synchronized-和-ReentrantLock的区别"><a href="#7、synchronized-和-ReentrantLock的区别" class="headerlink" title="7、synchronized 和 ReentrantLock的区别"></a>7、synchronized 和 ReentrantLock的区别</h3><ul><li>用法不同：synchronized 可以用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用于代码块</li><li>获取锁和释放锁的机制不同：synchronized 是自动加锁和释放锁的，而 ReentrantLock 需要手动加锁和释放锁</li><li>锁类型不同：synchronized 是非公平锁，而 ReentrantLock 默认为非公平锁，也可以手动指定为公平锁</li><li>响应中断不同：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断</li><li>底层实现不同：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的</li></ul><h3 id="8、synchronized-原理"><a href="#8、synchronized-原理" class="headerlink" title="8、synchronized 原理"></a>8、synchronized 原理</h3><ul><li>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(<strong>Monitor</strong>)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。</li><li>synchronized 修饰的代码块：使用<strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令来实现同步的。原理：<ul><li>我们通过解析synchronized修饰的代码块的字节码发现：同步语句块的实现使用的是monitorenter 和 monitorexit 指令。也就是在代码块的开始位置会添加一个monitorenter指令，在结束位置会添加一个monitorexit指令。</li><li>当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor（对象监听器：每个对象都会对应一个monitor） 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。</li><li>倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。</li><li>值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</li><li>总的来说，synchronized修饰代码块同步的底层原理就是在代码块的前后位置使用monitorenter和monitorexit 指令。monitorenter会判断是否可以获取当前对象锁的对象监听器，如果可以获取将就将其锁计数器加1。此时其他线程要获取该对象锁的对象监听器的时候就会被阻塞。直到当前线程执行monitorexit 指令，进行对象监听器的释放，同时将锁计数器减1。</li></ul></li><li>synchronized 修饰的同步方法：同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的。原理：<ul><li>方法级的同步是隐式的，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。</li><li>当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</li><li>在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。</li></ul></li></ul><h3 id="9、synchronized锁升级策略"><a href="#9、synchronized锁升级策略" class="headerlink" title="9、synchronized锁升级策略"></a>9、synchronized锁升级策略</h3><p>前言： 我们刚刚所提到的synchronized是通过获取monitor（对象监听器）实现的，监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，这种实现方式导致synchronized属于重量级锁。意思就是这种锁比较消耗系统内核资源，所以Java 6之后Java官方对从JVM层面对synchronized进行了优化，也就是所说的synchronized锁升级策略。</p><ul><li><p>偏向锁：</p><ul><li>偏向锁它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。</li><li>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。</li><li>所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</li></ul></li><li><p>轻量级锁：</p><ul><li>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</li></ul></li><li><p>自旋锁：</p><ul><li>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</li></ul></li><li><p>重量级锁：</p><ul><li>当自旋锁失败之后，就会升级成重量级锁了，也就是我们刚刚一直在讲述的synchronized的底层实现原理。</li></ul></li><li><p>消除锁：</p><ul><li>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</li></ul></li><li><p>锁升级策略概述：</p><ul><li>偏向锁：<ul><li>当锁对象第一次被线程获取的时候，线程使用CAS操作把这个锁的线程ID记录在对象头之中，同时置偏向标志位1。以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。</li><li>如果线程使用CAS操作时失败则表示该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁的所有权。当到达全局安全点（safepoint，这个时间点上没有正在执行的字节码）时获得偏向锁的线程被挂起，膨胀为轻量级锁。也就是说：当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束</li></ul></li><li>轻量级锁：<ul><li>当前线程使用CAS将对象头的mark Word锁标记位替换为锁记录指针,如果成功,当前线程获得锁。</li><li>如果失败，表示其他线程竞争锁,当前线程尝试通过自旋获取锁</li><li>如果自旋成功则依然处于轻量级状态</li><li>如果自旋失败,升级为重量级锁</li></ul></li><li>重量级锁： 此时就升级到重量级锁了</li></ul></li></ul><h3 id="10、ReentrantLock原理"><a href="#10、ReentrantLock原理" class="headerlink" title="10、ReentrantLock原理"></a>10、ReentrantLock原理</h3><ul><li><p>CAS操作：</p><ul><li>CAS是一种无锁算法。有3个操作数：内存值V、旧的预期值A、要修改的新值B。</li><li>当我们要修改内存值的时候要进行判断，当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li></ul></li><li><p>AQS队列</p><ul><li>AQS是一个用于构建锁和同步容器的框架。</li><li>AQS使用一个FIFO的队列（也叫CLH队列，是CLH锁的一种变形， 底层通过双向链表实现），表示排队等待锁的线程。队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus。</li></ul></li><li><p>ReentrantLock的锁流程</p><ul><li>ReentrantLock先通过CAS尝试获取锁，如果获取了就将锁状态state设置为1</li><li>如果此时锁已经被占用，<ul><li>被自己占用：判断当前的锁是否是自己占用了，如果是的话就锁计数器会state++（可重入性）</li><li>被其他线程占用：该线程加入AQS队列并wait()</li></ul></li><li>当前驱线程的锁被释放，一直到state&#x3D;&#x3D;0，挂在CLH队列为首的线程就会被notify()，然后继续CAS尝试获取锁，此时：<ul><li>非公平锁，如果有其他线程尝试lock()，有可能被其他刚好申请锁的线程抢占</li><li>公平锁，只有在CLH队列头的线程才可以获取锁，新来的线程只能插入到队尾。</li></ul></li></ul></li></ul><h3 id="11、公平锁与非公平锁"><a href="#11、公平锁与非公平锁" class="headerlink" title="11、公平锁与非公平锁"></a>11、公平锁与非公平锁</h3><ul><li>如果在绝对时间上，先对锁进行获取的请求一定先被满足，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。那么这个锁是公平的，反之，是不公平的</li><li>公平锁是严格的以FIFO的方式进行锁的竞争，但是非公平锁是无序的锁竞争，刚释放锁的线程很大程度上能比较快的获取到锁，队列中的线程只能等待，所以非公平锁可能会有“饥饿”的问题。但是重复的锁获取能减小线程之间的切换，而公平锁则是严格的线程切换，这样对操作系统的影响是比较大的，所以非公平锁的吞吐量是大于公平锁的，这也是为什么JDK将非公平锁作为默认的实现。<br>ReentrantLock既可以是公平锁又可以是非公平锁，synchronized 是非公平锁</li></ul><h3 id="12、乐观锁和悲观锁"><a href="#12、乐观锁和悲观锁" class="headerlink" title="12、乐观锁和悲观锁"></a>12、乐观锁和悲观锁</h3><ul><li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作</li><li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据</li></ul><h3 id="13、sleep-和-wait-的区别"><a href="#13、sleep-和-wait-的区别" class="headerlink" title="13、sleep 和 wait 的区别"></a>13、sleep 和 wait 的区别</h3><ul><li>sleep 方法是 Thread 类中的静态方法，wait 是Object类中的方法</li><li>sleep 并不会释放同步锁，而 wait 会释放同步锁</li><li>sleep 可以在任何地方使用，而 wait 只能在同步方法或同步代码块中使用</li><li>sleep 中必须传入时间，而 wait 可以传，也可以不传，不穿时间的话只有 notify 或者notifyAll 才能唤醒，传时间的话在时间之后才会唤醒</li></ul><h3 id="14、join、yield、interrupt、notify和notifyAll的作用"><a href="#14、join、yield、interrupt、notify和notifyAll的作用" class="headerlink" title="14、join、yield、interrupt、notify和notifyAll的作用"></a>14、join、yield、interrupt、notify和notifyAll的作用</h3><ul><li>join：当前线程里调用其它线程thread的join方法，当前线程进入WAITING&#x2F;TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程thread执行完毕或者millis时间到，当前线程进入就绪状态</li><li>yield：当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程</li><li>interrupt：当前线程里调用其它线程thread的interrupt()方法,中断指定的线程。如果指定线程调用了wait()方法或者join方法在阻塞状态，那么指定线程会抛出InterruptedException</li><li>notify：唤醒在此对象监视器（锁对象）上等待的单个线程，选择是任意性的</li><li>notifyAll：唤醒在此对象监视器（锁对象）上等待的所有线程</li></ul><h3 id="15、ThreadLocal的作用"><a href="#15、ThreadLocal的作用" class="headerlink" title="15、ThreadLocal的作用"></a>15、ThreadLocal的作用</h3><p>ThreadLocal的作用是提供线程内的局部变量，说白了，就是在各线程内部创建一个变量的副本，相比于使用各种锁机制访问变量，ThreadLocal的思想就是用空间换时间，使各线程都能访问属于自己这一份的变量副本，变量值不互相干扰，减少同一个线程内的多个函数或者组件之间一些公共变量传递的复杂度</p><h3 id="16、ThreadLocal的原理"><a href="#16、ThreadLocal的原理" class="headerlink" title="16、ThreadLocal的原理"></a>16、ThreadLocal的原理</h3><p>每个Thread对象都有一个ThreadLocalMap，ThreadLoalMap中初始化了一个大小16的Entry数组，Entry对象用来保存每一个key-value键值对。当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型，键值对以Entry类存储。</p><p><img src="C:\Users\zzp\AppData\Roaming\Typora\typora-user-images\image-20230312174042823.png" alt="image-20230312174042823"></p><h3 id="17、什么是死锁？死锁产生的原因？"><a href="#17、什么是死锁？死锁产生的原因？" class="headerlink" title="17、什么是死锁？死锁产生的原因？"></a>17、什么是死锁？死锁产生的原因？</h3><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止</p><p>原因：</p><ul><li>互斥条件：一个资源只能被一个线程占有，当这个资源被占有后其他线程就只能等待</li><li>不可剥夺条件：当一个线程不主动释放资源时，此资源一直被拥有线程占有</li><li>请求和保持条件：线程已经拥有了一个资源后，又尝试请求新的资源</li><li>环路等待条件：产生死锁一定是发生了线程资源环形链</li></ul><h3 id="18、自己写代码时如何有效避免死锁"><a href="#18、自己写代码时如何有效避免死锁" class="headerlink" title="18、自己写代码时如何有效避免死锁"></a>18、自己写代码时如何有效避免死锁</h3><ul><li><strong>设置超时时间</strong>：使用JUC包中的Lock接口提供的**<code>tryLock</code>**方法。该方法在获取锁的时候, 可以设置超时时间, 如果超过了这个时间还没拿到这把锁, 那么就可以做其他的事情, 而不是像<code>synchronized</code>如果没有拿到锁会一直等待下去</li><li><strong>多使用JUC包提供的并发类,而不是自己设计锁</strong>：JDK1.5后, 有JUC包提供并发类, 而不需要自己用wait 和notify来进行线程间的通信操作 , 这些成熟的并发类已经考虑的场景很完备了, 比自己设计锁更加安全。JUC中的并发类，例如 ConcurrentHashMap、ConcurrentLinkedQueue、AtomicBoolean 等等；实际应用中java.util.concurrent.atomic 包中提供的类使用广泛, 简单方便, 并且效率比Lock更高</li><li><strong>尽量降低锁的使用粒度</strong>：用不同的锁 ,而不是同一个锁。整个类如果使用一个锁来保护的话, 那么效率会很低, 而且有死锁的风险, 很多线程都来用这把锁的话, 就容易造成死锁。锁的使用范围, 只要能满足业务要求, 范围越小越好</li><li><strong>尽量使用同步代码块 而不是同步方法</strong>：<ul><li>同步方法是把整个方法给加上锁给同步了，范围较大，造成性能低下，使用同步代码块范围小，性能高</li><li>使用同步代码块, 可以自己指定锁的对象, 这样有了锁的控制权, 这样也能避免发生死锁</li></ul></li><li><strong>给线程起有意义的名字</strong></li><li><strong>避免锁的嵌套</strong></li><li><strong>分配锁资源之前先看能不能收回来资源</strong>：银行家算法</li><li><strong>专锁专用</strong></li></ul><h3 id="19、atomic-原理"><a href="#19、atomic-原理" class="headerlink" title="19、atomic 原理"></a>19、atomic 原理</h3><p>Atomic包的类的实现绝大调用Unsafe的方法，而Unsafe底层实际上是调用C代码，C代码调用汇编，最后生成出一条CPU指令cmpxchg，完成操作（<strong>CAS</strong>）。这也就为啥CAS是原子性的，因为它是一条CPU指令，不会被打断。</p><h3 id="20、线程池构造函数"><a href="#20、线程池构造函数" class="headerlink" title="20、线程池构造函数"></a>20、线程池构造函数</h3><ul><li><p><strong>corePoolSize：核心线程数</strong></p><ul><li>线程池维护的最小线程数量，核心线程创建后不会被回收（注意：设置 <code>allowCoreThreadTimeout = true</code> 后，空闲的核心线程超过存活时间也会被回收）</li><li>大于核心线程数的线程，在空闲时间超过keepAliveTime后会被回收</li><li>线程池刚创建时，里面没有一个线程，当调用 <code>execute()</code> 方法添加一个任务时，如果正在运行的线程数量小于corePoolSize，则马上创建新线程并运行这个任务</li></ul></li><li><p><strong>maximumPoolSize：最大线程数</strong></p><ul><li>线程池允许创建的最大线程数量。当添加一个任务时，核心线程数已满，工作队列已满的情况下，线程池还没达到最大线程数，并且没有空闲线程，创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部</li></ul></li><li><p><strong>keepAliveTime：空闲线程存活时间</strong></p><ul><li>当一个可被回收的线程的空闲时间大于<code>keepAliveTime</code>，就会被回收</li><li>可被回收的线程：<ol><li>设置<code>allowCoreThreadTimeout = true</code>的核心线程</li><li>大于核心线程数的线程（非核心线程）</li></ol></li></ul></li><li><p><strong>unit：时间单位</strong></p><ul><li>TimeUnit.NANOSECONDS&#x2F;&#x2F; 纳秒</li><li>TimeUnit.MICROSECONDS&#x2F;&#x2F; 微秒</li><li>TimeUnit.MILLISECONDS&#x2F;&#x2F; 毫秒</li><li>TimeUnit.SECONDS&#x2F;&#x2F; 秒</li><li>TimeUnit.MINUTES&#x2F;&#x2F; 分钟</li><li>TimeUnit.HOURS&#x2F;&#x2F; 小时</li><li>TimeUnit.DAYS</li></ul><p></p></li><li><p><strong>workQueue：工作队列</strong></p><ul><li><strong>作用</strong>：存放待执行任务的队列。当提交的任务数超过核心线程数大小后，再提交的任务就存放在工作队列，任务调度时再从队列中取出任务。它仅仅用来存放被 execute() 方法提交的 Runnable 任务。工作队列实现了 <strong>BlockingQueue</strong> 接口</li><li>JDK默认的工作队列有五种<ul><li><strong>ArrayBlockingQueue</strong>：数组型阻塞队列。<strong>数组结构，初始化时传入大小（有界），FIFO（先进先出策略）</strong>。使用一个重入锁（ReentrantLock），默认使用非公平锁，入队和出队共用一个锁，互斥</li><li><strong>LinkedBlockingQueue</strong>：链表型阻塞队列。<strong>链表结构，默认初始化大小为Integer.MAX_VALUE，有界（近似无界），FIFO（先进先出策略）</strong>。使用两个重入锁分别控制元素的入队和出队，用 Condition 进行线程间的唤醒和等待</li><li><strong>SynchronousQueue</strong>：同步移交队列。<strong>容量为0</strong>，添加任务必须等待取出任务，这个队列相当于通道，<strong>不存储元素</strong></li><li><strong>PriorityBlockingQueue</strong>：优先级阻塞队列。<strong>无界，在 put 的时候会tryGrow，要说它有界也没问题，因为界是 Integer.MAX_VALUE</strong>，但其实上这个队列应该是无界的。默认采用元素自然顺序升序排列（可以自定义Comparator）。使用一个重入锁分别控制元素的入队和出队</li><li><strong>DelayQueue</strong>：延时队列。<strong>无界，队列中的元素有过期时间，过期的元素才能被取出</strong>。使用一个重入锁分别控制元素的入队和出队，用 Condition 进行线程间的唤醒和等待。任务调度时候可以使用</li></ul></li></ul></li><li><p><strong>threadFactory：线程工厂</strong></p><ul><li>创建线程的工厂，可以设定线程名、线程编号等</li><li>默认创建的线程工厂，通过<code>Executors.defaultThreadFactory()</code>获取</li></ul></li><li><p><strong>handler：拒绝策略</strong></p><ul><li>当线程池线程数已满，并且工作队列达到限制，新提交的任务使用拒绝策略处理。可以自定义拒绝策略，拒绝策略需要实现 <strong>RejectedExecutionHandler</strong> 接口</li><li>JDK默认的拒绝策有四种<ul><li><strong>AbortPolicy</strong>：丢弃任务并抛出 RejectedExecutionException 异常（默认拒绝策略）</li><li><strong>DiscardPolicy</strong>：丢弃任务，但是不抛出异常。可能导致无法发现系统的异常状态</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列最前面的任务，然后重新提交被拒绝的任务</li><li><strong>CallerRunsPolicy</strong>：由调用线程处理该任务</li></ul></li></ul></li></ul><h3 id="21、线程池原理"><a href="#21、线程池原理" class="headerlink" title="21、线程池原理"></a>21、线程池原理</h3><img src="C:\Users\zzp\AppData\Roaming\Typora\typora-user-images\image-20230314093259155.png" alt="image-20230314093259155" style="zoom:80%;" /><h2 id="四、JVM"><a href="#四、JVM" class="headerlink" title="四、JVM"></a>四、JVM</h2><h3 id="1、JVM内存区域的划分"><a href="#1、JVM内存区域的划分" class="headerlink" title="1、JVM内存区域的划分"></a>1、JVM内存区域的划分</h3><p>JVM 的内存区域可以分为两类：线程私有和区域和线程共有的区域。线程私有的区域：程序计数器、JVM 虚拟机栈、本地方法栈。线程共有的区域：堆、方法区、运行时常量池</p><ul><li><p><strong>程序计数器</strong> ：每个线程有有一个私有的程序计数器，任何时间一个线程都只会有一个方法正在执行，也就是所谓的当前方法。程序计数器存放的就是这个当前方法的JVM指令地址</p></li><li><p><strong>JVM虚拟机栈</strong>：创建线程的时候会创建线程内的虚拟机栈，栈中存放着一个个的栈帧，对应着一个个方法的调用。JVM 虚拟机栈有两种操作，分别是压栈和出栈。栈帧中存放着局部变量表、方法返回值和方法的正常或异常退出的定义等等</p></li><li><p><strong>本地方法栈</strong>：跟 JVM 虚拟机栈比较类似，只不过它支持的是 Native 方法</p></li><li><p><strong>堆</strong>：堆是java内存中最大的一块，被所有线程共享，在虚拟机创建时创建，堆的唯一目的就是存放对象实例。<br>java堆是垃圾收集器管理的主要区域，所以又被叫为GC堆，现在收集器基本都是采用分代收集算法，所以java堆很可以细分新生代和老年代；新生代再细致一点的有Eden空间、From Survivor空间、To Survivor空间</p></li><li><p><strong>方法区</strong>：方法区是所有线程共享内存区域，它主要是被用来储存java虚拟机加载过类的类信息、常量、静态变量即编译器编译后的代码数据</p></li><li><p><strong>常量池</strong>：</p><ul><li>静态常量池(Class文件常量池)<br>静态常量池主要是存放编译后的字面量和符号引用，字面量相当于java语言层面的常量概念，如文本字符串，声明为final的常量值，符号引用则属于编译原理的内容，主要为：类和接口的全限定名、字段名称和描述符、方法名称和描述符。描述符的作用是用来描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值。</li><li>动态常量池(运行时常量池)<br>动态常量池是jvm虚拟机在完成类装载的操作后将静态常量池的常量保存在方法区中，动态常量池对比静态常量池具有动态性，并非Class文件常量池中的常量才能进入运行时常量池，运行期间也可以将新的常量放入池中，这种特性主要在String类中的inter()运用。</li></ul><img src="C:\Users\zzp\AppData\Roaming\Typora\typora-user-images\image-20230315212135170.png" alt="image-20230315212135170" style="zoom:67%;" /></li></ul><h3 id="2、JVM-哪些区域会发生-OOM"><a href="#2、JVM-哪些区域会发生-OOM" class="headerlink" title="2、JVM 哪些区域会发生 OOM"></a>2、JVM 哪些区域会发生 OOM</h3><p>除了程序计数器，其他的部分都会发生 OOM</p><ul><li><strong>堆内存</strong>，堆内存不足是最常见的发送OOM的原因之一。<br>如果在堆中没有内存完成对象实例的分配，并且堆无法再扩展时，将抛出OutOfMemoryError异常，抛出的错误信息是“java.lang.OutOfMemoryError:Java heap space”</li><li><strong>Java虚拟机栈和本地方法栈</strong>，这两个区域的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务，在内存分配异常上是相同的。<br>在JVM规范中，对Java虚拟机栈规定了两种异常：<br>a. 如果线程请求的栈大于所分配的栈大小，则抛出StackOverFlowError错误，比如进行了一个不会停止的递归调用；<br>b. 如果虚拟机栈是可以动态拓展的，拓展时无法申请到足够的内存，则抛出OutOfMemoryError错误</li><li>除了程序计数器，其他的部分都会发生 OOM</li></ul><h3 id="3、GC（垃圾回收）机制"><a href="#3、GC（垃圾回收）机制" class="headerlink" title="3、GC（垃圾回收）机制"></a>3、GC（垃圾回收）机制</h3><ul><li><p>内存标记算法：在内存被回收前，系统必须标记哪些内存已经没有人使用可以释放，这个工作就由内存标记算法的来完成，在Java各版本中，使用过如下几种标记算法。</p><ul><li><strong>引用计数法（Reference Counting）：</strong> 每个堆中分配的对象都有一个引用计数器，当一个对象被引用时，它的引用计数器会加一，垃圾回收时会清理掉引用计数为0的对象。但这种方法有一个问题，比方说有两个对象 A 和 B，A 引用了 B，B 又引用了 A，除此之外没有别的对象引用 A 和 B，那么 A 和 B 在我们看来已经是垃圾对象，需要被回收，但它们的引用计数不为 0，没有达到回收的条件。正因为这个循环引用的问题，Java 并没有采用引用计数法。</li><li><strong>可达性分析法（Reference Counting）：</strong> 又称跟踪算法（Tracing），算法引入了图论，把所有对象间的关系看成一张图，内存标记从一组根节点（GC Root Set）开始，通过递归搜索，建立对象的引用关系图，当搜索完毕后，图外的对象就是可回收对象。这是目前Java中使用的内存标记算法。根级对象一般包括 <strong>Java 虚拟机栈中的对象</strong>、<strong>本地方法栈中的对象</strong>、<strong>方法区中的静态对象</strong>和<strong>常量池中的常量</strong>。</li></ul></li><li><p>内存回收方式：</p><ul><li><p><strong>复制算法</strong>： 复制算法是将存活的对象复制到另一块内存区域中，并做相应的内存整理工作。复制算法的优点是可以避免内存碎片化，缺点也显而易见，它需要两倍的内存。</p></li><li><p><strong>标记-清除算法（Mark and Sweep）</strong>：</p><p>采用跟踪算法标记内存对象后，再扫描堆内存中未被标记的对象，进行回收。此算法不移动对象，仅对不存活对象进行回收，在存活对象占比高的情况下处理效率高，但不移动对象会引起内存碎片。</p></li><li><p><strong>标记-整理算法（Compacting）</strong>：<br>此方法和标记-清理算法使用相同标记算法，但在对不存活对象回收时，会把存活对象向内存前部空闲区域移动，同时更新对象的指针。此方法在清理的基础上，会对对象进行移动，执行成本较高，但可解决内存碎片问题。基于此算法的内存回收实现，一般会增加句柄和句柄表。</p></li><li><p><strong>分代回收策略</strong>：<br>JDK8中，堆中移除了永生代区域，堆内存主要由新生代和老年代两部分组成。其中新生代由一个伊甸园（Eden）和两个幸存者Survivor From和Survivor To 3部分组成，新创建对象首先保存在Eden中，当Eden中对象达到一定数量时，JVM触发Minor GC，GC时，先把Eden和From中的存活对象拷贝到Survivor To区，再清除Eden和From两个区域的数据，最后From和To互换身份，完成一次内存回收。新生代区域对象数量大，存活时间短，一般采用复制算法，通过这种结构和回收方式来提高垃圾回收效率，减少内存碎片。<br>经过若干（默认15）次后还存活的对象，将进入老年代区，当老年代数据满时，会触发Major GC（又称Full GC），此时新生代、老年代、元区域、直接内存区域都会执行GC操作。（<strong>大对象会直接进入老年代区</strong>，例如图片、很长的字符串及数组）</p></li></ul></li></ul><h3 id="4、Java-内存泄漏的原因"><a href="#4、Java-内存泄漏的原因" class="headerlink" title="4、Java 内存泄漏的原因"></a>4、Java 内存泄漏的原因</h3><ul><li><strong>静态集合类</strong>。如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</li><li><strong>单例模式</strong>。和静态集合导致内存泄漏原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象持有外部对象引用，那么这个外部对象也不会被回收，那么就会发生内存泄漏。<strong>要注意！！！！单例对象如果持有Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的Context最好是Application Context。</strong></li><li><strong>未关闭的资源类：如数据库连接、网络连接和IO连接等</strong>。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</li><li><strong>变量不合理的作用域</strong>。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</li><li><strong>非静态内部类持有外部类的引用。</strong>如果有地方引用了这个非静态内部类，会导致外部类也被引用。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</li><li><strong>改变哈希值</strong>。当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。</li><li><strong>缓存泄漏</strong>。内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘，对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</li><li><strong>监听器和回调</strong>。内存泄漏还有一个常见来源是监听器和其他回调，如果客户端在实现的API中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存他的弱引用，例如将他们保存成为WeakHashMap中的键。</li></ul><h3 id="5、Java-对象模型"><a href="#5、Java-对象模型" class="headerlink" title="5、Java 对象模型"></a>5、Java 对象模型</h3><p>在Hotspot虚拟机中，对象在内存中的存储布局分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><img src="C:\Users\zzp\AppData\Roaming\Typora\typora-user-images\image-20230312165224851.png" alt="image-20230312165224851" style="zoom:70%;" /><ul><li>对象头，又包括三部分：<strong>Mark Word</strong>、<strong>Klass Word</strong>（元数据指针）、<strong>数组长度</strong><ul><li><strong>Mark Word</strong>：用于存储对象运行时的数据，比如HashCode、锁状态标志、GC分代年龄等。这部分在64位操作系统下，占8字节（64bit），在32位操作系统下，占4字节（32bit）。</li><li><strong>Klass Word</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。这部分就涉及到一个指针压缩的概念，在开启指针压缩的情况下，占4字节（32bit），未开启情况下，占8字节（64bit），现在JVM在1.6之后，在64位操作系统下都是默认开启的。</li><li><strong>数组长度</strong>：这部分只有是数组对象才有，如果是非数组对象，就没这部分了，这部分占4字节（32bit）。</li></ul></li></ul><h3 id="6、一个空对象占用多少字节"><a href="#6、一个空对象占用多少字节" class="headerlink" title="6、一个空对象占用多少字节"></a>6、一个空对象占用多少字节</h3><p>只要是Java对象，那么就肯定会包括对象头，也就是说这部分内存占用是避免不了的。所以，在64位虚拟机，Jdk1.8（开启了指针压缩）的环境下，任何一个对象，啥也不做，只要声明一个类，那么它的内存占用就至少是96bits，也就是至少12字节，加上<strong>内存对齐</strong>填充的6字节，总共占用16字节。而不开启指针压缩情况下，则占用16字节。在32位虚拟机，一个空对象占用8字节（对象头）。</p><h3 id="7、什么是内存对齐"><a href="#7、什么是内存对齐" class="headerlink" title="7、什么是内存对齐"></a>7、什么是内存对齐</h3><p>CPU 并不会以一个一个字节去读取和写入内存。相反，CPU 读取内存是一块一块读取的，块的大小可以为 2、4、6、8、16 字节等大小。块大小我们称其为内存访问粒度。假设一个32位平台的 CPU，那它就会以4字节为粒度去读取内存块，64位平台的 CPU则会以8字节为粒度去读取内存块。那为什么需要内存对齐呢？主要有两个原因：</p><ul><li><strong>平台（移植性）原因</strong>：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况。</li><li><strong>性能原因</strong>：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作。</li></ul><h3 id="8、什么是指针压缩（64位才支持）"><a href="#8、什么是指针压缩（64位才支持）" class="headerlink" title="8、什么是指针压缩（64位才支持）"></a>8、什么是指针压缩（64位才支持）</h3><p>当我们启用了<code>-XX:+UseCompressedOops</code>之后，我们原本的OOP（Ordinary Object Pointer，普通对象指针）就会被压缩，当然也不是所有的对象都会被压缩，只有 以下几种的对象才会被压缩：</p><ul><li>对象的全局静态变量（类属性）</li><li>对象头中Klass Word信息</li><li>对象的引用类型</li><li>对象数组类型</li></ul><p>而以下几种对象则不能被压缩：</p><ul><li>指向PermGen的Class对象指针</li><li>局部变量</li><li>传参</li><li>返回值</li><li>NULL指针</li></ul><p>指针压缩的大概原理： 通过对齐，还有偏移量将64位指针压缩成32位。零基压缩是针对压缩解压动作的进一步优化。 它通过改变正常指针的随机地址分配特性，强制堆地址从零开始分配。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阅文面试</title>
      <link href="/2024/05/20/%E9%98%85%E6%96%87%E9%9D%A2%E8%AF%95/"/>
      <url>/2024/05/20/%E9%98%85%E6%96%87%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="47fcad5cc07ce7b96fab98ae5958a6c0231ec7defda559e7041224f9ac3187fd">219088d7278b870cf4c68cad190c40547bff7cf83a5efc4c479d2dd291d2a7c200bfc9ca847be55befd2970f9c579e5f44e190fba84027f745d880e1711abe553e2f173dbadb9543f7b0dfc5870e697c71231ee0784bb30ae5b6575589f1e2a31eaa137d4580b466f7bfee727630e2cc201b61d9a92d1ceb1b492b4b26481460a1cbfc50b541698d70426634c62e14a436c323dcf92559b16d42e7abaca7eb7e25b4d237f819135709c04fc3f5f650e63e9e63c1c76c57aceb6bf1601b34fdb1ba89eebde1a55f9d342754fe9bb253db089690b16c0cbb33829446ce96973a26430b7c5e3afa309be7a92d1eb5453b862e88443a59eee0cd591e0f4806a04144f19269774722d982b3a7efc544101c0499eac2c798ea98f37c59e64d0ea9102a49500fe5084730bc26cbb8bf8abb8a416ef5ac274440bcee7c48e7d4d15b847c21bf779e098fcb342befea270a4fac638dd71f76b65fb47b088c1328674bc122becb01243b4db1081f187116cb301739c7c5271ea532d7399c1c38652b8670c7716fd018c1370e7465e5ad25e16d784838444427cd7d15723fdc7868e74af40c5da7ac47f53c95d893ed368b7510fac60e106a79abba1af2dca8d84a8c2a5b650994d8666fcdb53c2eba67ed718ac25f42fc85d74b4973284ce9e74cff28c91035cbf9d737c2fee53c8f8072e920404a300ab578ebef47cbc951016aec25eac19bbbc6d46a7de813eb3d1b18edf6c321c99d8e2060484d91af62e532f677cf656a3d5702cd93a410c071b325cbb761322814f93026948a3cdcd91b10fc48bef0e3b179d5f00b86374e9eabf78b9780af19509d3ab147927ad12a4ce81c976415572d6c6f3ec30ec24afb09e3a6395c0e2c734c392009c26b2c46344251c4788153d180a1aa41e5da1c10672889c590e0d870f8da4c430fb8b631f2d44215f5f3f636bf37e55ec0d5fcccd0106d44f9e85fa775e2a5c8da5317c055e1035a90a8e0f9570c221e34f54c19ec06bf9a5b0f3e8771e83cac033e0aa09de12150980ab4f8e1a62ac3b2bc2ead475795d35672dbac41875af8630050865f27e6d251c31467f53d054793709c4d5f1c0c3270ab63448c64c6e6298a573d4118dc91061ab905d0d98736bda929325d11124fbc8c577c90264f07396d6ae37f4ab58c450a292bbf66fd338d80e4dae83dfc83c43bff2eb69d90729cec526c79e5177c278896afbab6145d33b87b368c91cbb07859d9aadfe851e5590a5c89a7f8d343427933fb7ec7f6b93746355ca9942d5d318d778d451bb2a50cf21c43f2a2c79bb1185ceb5f4bd2af8b2408c8f67c8ad635062c7e7f2fdef7c5acf67f9f6c7967ec6a64ecfc02d38740cf388121663b1a283783b36dabb9748d3659574985c76b2bf9e5d254319e97804d7acee02eb861763e1e71a2926c194f614fa742d550f5d3ea4855eb3f102859d653239ee94d165fbb4fb553f2d1de8c197ec08aaef140dcc61761ec56d2b798a7d6c83cc4565024a7c6ed6dd4ce4e2a9f241dd1d5d137616dc277e3500ad69a262e7eea3f259bb3a25ae7ab38b8d2be6685b4b5d9a7d510432763725a3dd4ce6b3f08bf2baa53e8bcc9f9a9be546d472d869e200d058e2a9e41a4436edf71d63206c5950112deef3103f830b12674d79720f2cdabf38df6c19cd8cd19960ff346a6f84bd1428552d500653e3341c99fc695bf32ea63e833d54b59497ef506fac4d873104d50b8342aebedb1292605a7e2f78edee4d6b74212ddc2a1be3fdfe3750c2f78a5b4448867614773988561fb736c6827b41cd1cc503efccdd780ba01e0a0506f0913abb5317f4d1097034dbac49de42384be2b13259acdbf83f11a65c5497ce7c974ac567d900d7f8d9d58dc4f8c33b2405e577cadc7b4d4dd3f110a6c4741c4749e38bef94374873b9ad9b3d3e5897db0bc9ebbdaea0987b46e95209721b990946be56bc84a584f6c2da2d867c13df76b6cee8862650364b5b13b6e3791605b3621a3004f6a84002cfe39e68e10716fec630b898dfde830ecc6a41018cc5673c9d52029f0f1ace5f4c4516c89786d9d9916860ff2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓面试重点</title>
      <link href="/2024/05/18/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9/"/>
      <url>/2024/05/18/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安卓四大组件"><a href="#1-安卓四大组件" class="headerlink" title="1. 安卓四大组件"></a>1. 安卓四大组件</h2><ul><li>Activity</li><li>service</li><li>broadcast Receiver</li><li>content Provider</li></ul><h2 id="2-Activity的生命周期"><a href="#2-Activity的生命周期" class="headerlink" title="2. Activity的生命周期"></a>2. Activity的生命周期</h2><p>onCreate() &#x3D;&gt; onStart() &#x3D;&gt; onResume()  &#x3D;&gt; onPause() &#x3D;&gt; onStop() &#x3D;&gt;onRestart()&#x3D;&gt; onDestrory()</p><h3 id="按home键返回桌面后再次进入生命周期是什么样的？"><a href="#按home键返回桌面后再次进入生命周期是什么样的？" class="headerlink" title="按home键返回桌面后再次进入生命周期是什么样的？"></a>按home键返回桌面后再次进入生命周期是什么样的？</h3><ol><li>启动：onCreat-&gt;onStart-&gt;onResume</li><li>HOME键的执行顺序：onPause-&gt;onStop-&gt;onRestart-&gt;onStart-&gt;onResume</li></ol><p>下面的不用</p><ol><li>BACK键的顺序： onPause-&gt;onStop-&gt;onDestroy-&gt;onCreate-&gt;onStart-&gt;onResume</li></ol><h3 id="生命周期具体场景示例"><a href="#生命周期具体场景示例" class="headerlink" title="生命周期具体场景示例"></a>生命周期具体场景示例</h3><ol><li>启动Activity：系统会先调用<strong>onCreate</strong>方法，然后调用<strong>onStart</strong>方法，最后调用<strong>onResume</strong>，Activity进入运行状态。</li><li>当前Activity被其他Activity覆盖其上或被锁屏：系统会调用<strong>onPause</strong>方法，暂停当前Activity的执行。</li><li>当前Activity由被覆盖状态回到前台或解锁屏：系统会调用<strong>onResume</strong>方法，再次进入运行状态。</li><li>当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用<strong>onPause</strong>方法，然后调用<strong>onStop</strong>方法，进入停滞状态。</li><li>用户后退回到此Activity：系统会先调用<strong>onRestart</strong>方法，然后调用<strong>onStart</strong>方法，最后调用<strong>onResume</strong>方法，再次进入运行状态。</li><li>当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用<strong>onCreate</strong>方法、<strong>onStart</strong>方法、<strong>onResume</strong>方法，进入运行状态。</li><li>用户退出当前Activity：系统先调用<strong>onPause</strong>方法，然后调用<strong>onStop</strong>方法，最后调用<strong>onDestory</strong>方法，结束当前Activity</li></ol><h2 id="3-Fragment的生命周期"><a href="#3-Fragment的生命周期" class="headerlink" title="3. Fragment的生命周期"></a>3. Fragment的生命周期</h2><p>onAttach() &#x3D;&gt; oncreate() &#x3D;&gt; onCreateView() &#x3D;&gt; onActivityCreate() &#x3D;&gt; onDestroyView() &#x3D;&gt; onDetach()</p><h2 id="4-service-的生命周期，两种启动方式的区别"><a href="#4-service-的生命周期，两种启动方式的区别" class="headerlink" title="4. service 的生命周期，两种启动方式的区别"></a>4. service 的生命周期，两种启动方式的区别</h2><p><strong>startService</strong> </p><p>onCreate() -&gt; onStartCommand() -&gt; onDestroy()</p><p> <strong>bindService</strong></p><p> onCreate() -&gt; onbind() -&gt; onUnbind()-&gt; onDestroy() </p><p><strong>区别</strong></p><p> <strong>启动</strong> </p><p>如果服务已经开启，多次执行startService不会重复的执行onCreate()， 而是会调用onStart()和 onStartCommand()。</p><p> 如果服务已经开启，多次执行bindService时,onCreate和onBind方法并不会被多次调用 </p><p><strong>销毁</strong></p><p> 当执行stopService时，直接调用onDestroy方法 </p><p>调用者调用unbindService方法或者调用者Context不存在了（如Activity被finish了），Service就会调用 onUnbind-&gt;onDestroy </p><p>使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服 务仍然运行。 </p><p>使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止。</p><p> 1、单独使用startService &amp; stopService </p><p>（1）第一次调用startService会执行onCreate、onStartCommand。 </p><p>（2）之后再多次调用startService只执行onStartCommand，不再执行onCreate。 </p><p>（3）调用stopService会执行onDestroy。</p><p>2、单独使用bindService &amp; unbindService </p><p>（1）第一次调用bindService会执行onCreate、onBind。 </p><p>（2）之后再多次调用bindService不会再执行onCreate和onBind。</p><p>（3）调用unbindService会执行onUnbind、onDestroy。</p><h2 id="5-Activity的四种启动模式"><a href="#5-Activity的四种启动模式" class="headerlink" title="5. Activity的四种启动模式"></a>5. Activity的四种启动模式</h2><ul><li><strong>standard（标准模式）</strong>：如果在mainfest中不设置就默认standard。standard就是新建一个Activity就在栈中新建一个activity实例；</li><li><strong>singleTop（栈顶复用模式）</strong>：与standard相比栈顶复用可以有效减少activity重复创建对资源的消耗，但是这要根据具体情况而定，不能一概而论；</li><li><strong>singleTask（栈内单例模式）</strong>：栈内只有一个activity实例，栈内已存activity实例，在其他activity中start这个activity，Android直接把这个实例上面其他activity实例踢出栈GC掉；</li><li><strong>singleInstance（堆内单例）</strong> ：整个手机操作系统里面只有一个实例存在就是内存单例；如APP经常调用的拨打电话、系统通讯录、系统Launcher、锁屏键、来电显示等系统应用。singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。</li></ul><p>在singleTop、singleTask、singleInstance 中如果在应用内存在Activity实例，并且再次发生startActivity(Intent intent)回到Activity后,由于并不是重新创建Activity而是复用栈中的实例，因此Activity再获取焦点后并没调用onCreate、onStart，而是直接调用了onNewIntent(Intent intent)函数。</p><h2 id="6-进程，线程，协程的关系"><a href="#6-进程，线程，协程的关系" class="headerlink" title="6. 进程，线程，协程的关系"></a>6. 进程，线程，协程的关系</h2><p>进程（Process）、线程（Thread）和协程（Coroutine）都是计算机科学中用于管理和执行任务的概念，它们之间有一些相似性和区别。</p><ol><li><strong>进程（Process）</strong>：<ul><li>进程是操作系统分配资源的基本单位，每个进程都有独立的内存空间和执行环境。</li><li>进程之间相互独立，彼此之间不能直接访问彼此的内存空间，通信需要通过特定的机制，比如进程间通信（IPC）。</li><li>每个进程都拥有独立的地址空间，包括代码、数据和堆栈，因此进程之间的切换开销相对较大。</li></ul></li><li><strong>线程（Thread）</strong>：<ul><li>线程是进程内的执行单元，多个线程可以共享同一个进程的资源，如内存空间和文件句柄。</li><li>同一进程内的线程之间可以直接访问共享的内存空间，因此线程间通信相对简单，但需要注意同步和互斥。</li><li>线程共享进程的地址空间，因此线程之间的切换开销相对较小。</li></ul></li><li><strong>协程（Coroutine）</strong>：<ul><li>协程是一种用户态的轻量级线程，它可以在执行过程中暂停和恢复，而不是像线程那样被操作系统调度。</li><li>协程可以避免创建大量线程的开销，提高并发程序的性能和可读性。</li><li>协程通常是由程序员显式地控制调度，而不是依赖于操作系统的线程调度器。</li><li>协程通常使用异步编程模式来实现非阻塞的并发操作，例如在 I&#x2F;O 操作中等待结果而不阻塞线程。</li></ul></li></ol><p>关于它们的关系：</p><ul><li>一个进程可以包含多个线程，这些线程共享该进程的资源，但彼此之间相对独立。</li><li>协程通常运行在线程之上，一个线程可以包含多个协程，但协程之间也是相对独立的，它们可以在需要时挂起和恢复。</li></ul><h2 id="7-Handler机制"><a href="#7-Handler机制" class="headerlink" title="7. Handler机制"></a>7. Handler机制</h2><p>说到 Handler，就不得不提与之密切相关的这几个类：Message、MessageQueue，Looper。</p><ul><li><strong>Message</strong>：Message 中有两个成员变量值得关注：target 和 callback。<ul><li>target 其实就是发送消息的 Handler 对象</li><li>callback 是当调用 <code>handler.post(runnable)</code> 时传入的 Runnable 类型的任务。post 事件的本质也是创建了一个 Message，将我们传入的这个 runnable 赋值给创建的Message的 callback 这个成员变量。</li></ul></li><li><strong>MessageQueue</strong>: 消息队列很明显是存放消息的队列，值得关注的是 MessageQueue 中的 <code>next()</code> 方法，它会返回下一个待处理的消息。</li><li><strong>Looper</strong>：Looper 消息轮询器其实是连接 Handler 和消息队列的核心。如果想要在一个线程中创建一个 Handler，首先要通过<code>Looper.prepare()</code>创建 Looper，之后还得调用<code>Looper.loop()</code>开启轮询。<ul><li>**<code>prepare()</code>**： 这个方法做了两件事：首先通过<code>ThreadLocal.get()</code>获取当前线程中的Looper，如果不为空，则会抛出一个RunTimeException，意思是一个线程不能创建2个Looper。如果为null则执行下一步。第二步是创建了一个Looper，并通过 <code>ThreadLocal.set(looper)。</code>将我们创建的Looper与当前线程绑定。这里需要提一下的是消息队列的创建其实就发生在Looper的构造方法中。</li><li>**<code>loop()</code>**： 这个方法开启了整个事件机制的轮询。它的本质是开启了一个死循环，不断的通过 <code>MessageQueue的next()</code>方法获取消息。拿到消息后会调用 <code>msg.target.dispatchMessage()</code>来做处理。其实我们在说到 Message 的时候提到过，<code>msg.target</code> 其实就是发送这个消息的 handler。这句代码的本质就是调用 <code>handler的dispatchMessage()。</code></li></ul></li><li><strong>Handler</strong>：Handler 的分析着重在两个部分：发送消息和处理消息。<ul><li><strong>发送消息</strong>：其实发送消息除了 sendMessage 之外还有 sendMessageDelayed 和 post 以及 postDelayed 等等不同的方式。但它们的本质都是调用了 sendMessageAtTime。在 sendMessageAtTime 这个方法中调用了 enqueueMessage。在 enqueueMessage 这个方法中做了两件事：通过<code>msg.target = this</code>实现了消息与当前 handler 的绑定。然后通过<code>queue.enqueueMessage</code>实现了消息入队。</li><li><strong>处理消息</strong>： 消息处理的核心其实就是<code>dispatchMessage()</code>这个方法。这个方法里面的逻辑很简单，先判断 <code>msg.callback</code> 是否为 null，如果不为空则执行这个 runnable。如果为空则会执行我们的<code>handleMessage</code>方法。</li></ul></li></ul><h2 id="8-MVP、MVC、MVVM-架构模式"><a href="#8-MVP、MVC、MVVM-架构模式" class="headerlink" title="8. MVP、MVC、MVVM 架构模式"></a>8. MVP、MVC、MVVM 架构模式</h2><p>在 Android 开发中，MVP（Model-View-Presenter）、MVC（Model-View-Controller）和 MVVM（Model-View-ViewModel）是常用的架构模式，它们都旨在帮助开发者组织代码、提高代码的可读性和可维护性。以下是它们的简要介绍：</p><ol><li><strong>MVP（Model-View-Presenter）</strong>：<ul><li>MVP 是一种经典的架构模式，将应用程序分为三个主要部分：Model、View 和 Presenter。</li><li>Model 表示数据模型或业务逻辑，View 表示用户界面，Presenter 作为 View 和 Model 之间的中介，负责处理业务逻辑和更新视图。</li><li>在 MVP 中，View 通常是 passively（被动的），它只负责展示数据和将用户输入传递给 Presenter；Presenter 负责处理用户输入、更新 View 和与 Model 进行交互。</li></ul></li><li><strong>MVC（Model-View-Controller）</strong>：<ul><li>MVC 是另一种经典的架构模式，也将应用程序分为三个部分：Model、View 和 Controller。</li><li>Model 表示数据和业务逻辑，View 表示用户界面，Controller 负责处理用户输入、更新 Model 和 View。</li><li>在 Android 中，MVC 的实现方式可能会有所不同，通常是 Activity 或 Fragment 充当 Controller，负责协调 Model 和 View。</li></ul></li><li><strong>MVVM（Model-View-ViewModel）</strong>：<ul><li>MVVM 是一种相对较新的架构模式，它将应用程序分为三个部分：Model、View 和 ViewModel。</li><li>Model 表示数据和业务逻辑，View 表示用户界面，ViewModel 作为 View 和 Model 之间的中介，负责管理视图的状态、处理用户输入和更新 Model。</li><li>ViewModel 通常通过数据绑定库（如 Android Architecture Components 中的 LiveData 和 DataBinding）与 View 进行绑定，使 View 在 ViewModel 的状态变化时自动更新。</li></ul></li></ol><p>每种架构模式都有其优点和适用场景，选择合适的架构模式取决于项目的需求、团队的技术水平和个人偏好。MVP 适合需要测试和解耦的项目，MVC 适用于简单的项目，而 MVVM 则适用于需要利用数据绑定和响应式编程的项目。</p><h2 id="9-RecyclerView"><a href="#9-RecyclerView" class="headerlink" title="9.  RecyclerView"></a>9.  RecyclerView</h2><p>​1.具有多久缓存机制</p><p>​2.滑动回收复用机制</p><p>​3.刷新回收复用机制</p><p>​4.具有预布局的效果</p><h3 id="ListView-和RecyclerView的区别"><a href="#ListView-和RecyclerView的区别" class="headerlink" title="ListView 和RecyclerView的区别"></a>ListView 和RecyclerView的区别</h3><ol><li><p>布局效果 </p><p>ListView 的布局比较单一，只有一个纵向效果； RecyclerView 的布局效果丰富， 可以在 LayoutMananger 中 设置：线性布局（纵向，横向），表格布局，瀑布流布局</p></li><li><p>局部刷新</p><p>RecyclerView中可以实现局部刷新，例如：notifyItemChanged()； 如果要在ListView实现局部刷新，依然是可以实现的，当一个item数据刷新时，我们可以在Adapter中，实现一 个notifyItemChanged()方法，在方法里面通过这个 item 的 position，刷新这个item的数据</p></li><li><p>缓存区别</p></li></ol><p>​ListView有两级缓存，在屏幕与非屏幕内。 RecyclerView比ListView多两级缓存 ListView缓存View。 RecyclerView缓存RecyclerView.ViewHolder</p><h3 id="用过listView和recyclerview吗？有什么优化的地方"><a href="#用过listView和recyclerview吗？有什么优化的地方" class="headerlink" title="用过listView和recyclerview吗？有什么优化的地方"></a>用过listView和recyclerview吗？有什么优化的地方</h3><h3 id="优化方面："><a href="#优化方面：" class="headerlink" title="优化方面："></a>优化方面：</h3><ol><li><strong>ListView中的getView方法中复用contentView</strong>：<ul><li>在ListView的getView方法中，可以通过convertView参数来重用已经存在的视图，以减少内存消耗和提高性能。如果convertView不为null，可以直接对其进行重用，而不是每次都创建新的视图。</li></ul></li><li><strong>RecyclerView避免重复创建点击事件</strong>：<ul><li>在RecyclerView中，可以在ViewHolder中为itemView设置点击事件，而不是在每次绑定数据时都创建新的点击事件监听器。这样可以减少内存消耗，并提高性能。</li></ul></li><li><strong>布局优化</strong>：<ul><li>在布局方面，尽量减少嵌套层级，使用相对布局或者约束布局等能够提高布局性能的布局方式。另外，避免使用过多的复杂布局和不必要的视图，可以减少渲染时间和内存消耗。</li></ul></li></ol><h3 id="RecyclerView如何复用itemView："><a href="#RecyclerView如何复用itemView：" class="headerlink" title="RecyclerView如何复用itemView："></a>RecyclerView如何复用itemView：</h3><p>RecyclerView通过ViewHolder模式来复用itemView，这是其性能优势之一。当RecyclerView需要显示新的数据时，它会首先检查是否有可重用的ViewHolder可用，如果有，则会使用这些ViewHolder，而不是创建新的。这样做可以大大减少内存消耗和布局的层级。</p><p>具体来说，RecyclerView在初始化时会创建一定数量的ViewHolder，并在需要时将它们绑定到特定的数据上。当itemView滚出屏幕时，对应的ViewHolder会被标记为可重用，并保留在内存中，以便在需要时进行重用。这样，即使有大量的数据需要显示，也只需创建足够数量的ViewHolder，而不需要为每个数据项都创建一个新的视图。</p><p>这种重用机制使得RecyclerView能够高效地处理大量数据，并在滚动时保持流畅性能，因为它不需要频繁地创建和销毁视图。</p><h2 id="10-TCP-和-UDP-区别"><a href="#10-TCP-和-UDP-区别" class="headerlink" title="10. TCP 和 UDP 区别"></a>10. TCP 和 UDP 区别</h2><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？(opens new window)</a></li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><p><strong>TCP 和 UDP 应用场景：</strong></p><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP &#x2F; HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li><p>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</p></li><li><p>视频、音频等多媒体通信；</p></li><li><p>广播通信；</p><h3 id="TCP实现原理（三次握手，四次挥手），为什么不能改成两次"><a href="#TCP实现原理（三次握手，四次挥手），为什么不能改成两次" class="headerlink" title="TCP实现原理（三次握手，四次挥手），为什么不能改成两次"></a>TCP实现原理（三次握手，四次挥手），为什么不能改成两次</h3></li></ul><p> TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的传输协议。在建立连接和断开连接时，TCP 需要进行三次握手和四次挥手。</p><h3 id="三次握手（Connection-Establishment）："><a href="#三次握手（Connection-Establishment）：" class="headerlink" title="三次握手（Connection Establishment）："></a>三次握手（Connection Establishment）：</h3><ol><li><strong>客户端发送 SYN</strong>：客户端向服务器发送一个 SYN（同步）标志的数据包，表示客户端请求建立连接。</li><li><strong>服务器发送 SYN-ACK</strong>：服务器收到客户端的 SYN 数据包后，会向客户端发送一个 SYN-ACK（同步-确认）标志的数据包，表示服务器收到了客户端的请求，并同意建立连接。</li><li><strong>客户端发送 ACK</strong>：客户端收到服务器的 SYN-ACK 数据包后，会向服务器发送一个 ACK（确认）标志的数据包，表示客户端收到了服务器的确认，连接建立成功。</li></ol><h3 id="四次挥手（Connection-Termination）："><a href="#四次挥手（Connection-Termination）：" class="headerlink" title="四次挥手（Connection Termination）："></a>四次挥手（Connection Termination）：</h3><ol><li><strong>客户端发送 FIN</strong>：当客户端想要断开连接时，它向服务器发送一个 FIN（结束）标志的数据包，表示客户端不再发送数据了，但仍然可以接收数据。</li><li><strong>服务器发送 ACK</strong>：服务器收到客户端的 FIN 数据包后，会向客户端发送一个 ACK 标志的数据包，表示服务器收到了客户端的请求，但服务器仍然可以向客户端发送数据。</li><li><strong>服务器发送 FIN</strong>：当服务器准备好断开连接时，它向客户端发送一个 FIN 标志的数据包，表示服务器不再发送数据了，但仍然可以接收数据。</li><li><strong>客户端发送 ACK</strong>：客户端收到服务器的 FIN 数据包后，会向服务器发送一个 ACK 标志的数据包，表示客户端收到了服务器的请求，连接断开成功。</li></ol><p>挥手过程为什么是四次呢？这是因为 TCP 是全双工的，即数据可以双向传输。在断开连接时，需要分别关闭客户端到服务器和服务器到客户端的数据流。因此，需要分别发送 FIN 和 ACK，所以挥手过程是四次。这样可以确保数据的完整传输，并且在断开连接后双方都不再发送数据。</p><h4 id="两次握手导致的问题"><a href="#两次握手导致的问题" class="headerlink" title="两次握手导致的问题"></a>两次握手导致的问题</h4><ol><li><strong>可能存在已失效的连接请求</strong>：假设客户端发送了连接请求 SYN，但由于某种原因导致该请求在网络中滞留，没有到达服务器。如果此时服务器接收不到客户端的连接请求，它就不会发送 SYN-ACK 回复。但客户端并不知道自己的连接请求是否已经到达服务器，它可能会误以为连接已经建立成功。这样就可能导致客户端和服务器之间出现已失效的连接请求，从而造成资源浪费。</li><li><strong>可能出现网络中重复的连接请求</strong>：假设客户端发送了连接请求 SYN，但由于某种原因导致客户端没有收到服务器的 SYN-ACK 回复。在这种情况下，客户端会重新发送连接请求 SYN。如果之前的连接请求在网络中突然出现并到达服务器，而服务器此时又接收到了客户端的新连接请求 SYN，那么服务器可能会误认为客户端发送了两次连接请求，从而建立两个连接。这样就可能导致网络中出现重复的连接请求，产生混乱。</li></ol><h2 id="11-HTTP-和-HTTPS"><a href="#11-HTTP-和-HTTPS" class="headerlink" title="11. HTTP 和 HTTPS"></a>11. HTTP 和 HTTPS</h2><p>HTTP是超文本传输协议，HTTPS是超文本传输安全协议。</p><p>HTTP协议是双向协议。</p><p>HTTPS比HTTP传输更加安全。</p><h3 id="HTTP的状态码有哪一些"><a href="#HTTP的状态码有哪一些" class="headerlink" title="HTTP的状态码有哪一些"></a>HTTP的状态码有哪一些</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p><ul><li>1XX 表示提示信息</li><li>2XX 表示成功</li><li>3XX 表示重定向</li><li>4XX 表示客户端错误</li><li>5XX 表示服务器错误</li></ul><h3 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h3><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h2 id="12-OkHttp"><a href="#12-OkHttp" class="headerlink" title="12. OkHttp"></a>12. OkHttp</h2><h3 id="1-创建-OkHttpClient-对象"><a href="#1-创建-OkHttpClient-对象" class="headerlink" title="1.创建 OkHttpClient 对象"></a>1.创建 OkHttpClient 对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br></pre></td></tr></table></figure><p>OkHttpClient中的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">OkHttpClient</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">Builder</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-发起-HTTP-请求"><a href="#2-发起-HTTP-请求" class="headerlink" title="2. 发起 HTTP 请求"></a>2. 发起 HTTP 请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog.piasy.com/img/201607/okhttp_full_process.png" alt="okhttp\_full\_process"></p><h2 id="13-Retrofit"><a href="#13-Retrofit" class="headerlink" title="13. Retrofit"></a>13. Retrofit</h2><h3 id="创建-Retrofit-对象"><a href="#创建-Retrofit-对象" class="headerlink" title="创建 Retrofit 对象"></a>创建 Retrofit 对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="定义-API-并获取-API-实例"><a href="#定义-API-并获取-API-实例" class="headerlink" title="定义 API 并获取 API 实例"></a>定义 API 并获取 API 实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface GitHubService &#123;</span><br><span class="line">  @GET(&quot;users/&#123;user&#125;/repos&quot;)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GitHubService github = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure><h3 id="OkHttp和Retrofit区别"><a href="#OkHttp和Retrofit区别" class="headerlink" title="OkHttp和Retrofit区别"></a>OkHttp和Retrofit区别</h3><h3 id="OkHttp："><a href="#OkHttp：" class="headerlink" title="OkHttp："></a>OkHttp：</h3><ol><li><strong>底层网络库</strong>：OkHttp是一个强大的HTTP客户端，提供了丰富的功能来处理HTTP请求和响应，如连接池管理、请求重试、缓存等。</li><li><strong>轻量级</strong>：OkHttp的设计简单，体积小巧，易于集成到Android应用中。</li><li><strong>灵活性</strong>：OkHttp提供了丰富的API和扩展点，可以轻松地实现自定义的网络功能和拦截器。</li><li><strong>支持HTTP&#x2F;2和WebSocket</strong>：OkHttp支持HTTP&#x2F;2协议和WebSocket协议，可以提供更快的网络请求和实时通讯功能。</li></ol><h3 id="Retrofit："><a href="#Retrofit：" class="headerlink" title="Retrofit："></a>Retrofit：</h3><ol><li><strong>基于注解的声明式HTTP客户端</strong>：Retrofit是一个基于注解和接口的声明式HTTP客户端，使得定义和调用HTTP API变得更加简洁和易于理解。</li><li><strong>与OkHttp配合使用</strong>：Retrofit底层使用OkHttp来处理网络请求，因此继承了OkHttp的性能优势和功能特性。</li><li><strong>简化网络请求流程</strong>：Retrofit封装了网络请求的细节，使得网络请求的创建和调用变得更加简单和高效，同时支持同步和异步请求。</li><li><strong>支持多种数据转换器</strong>：Retrofit支持多种数据格式的转换器，如JSON、Protobuf、Gson等，可以灵活地处理不同格式的数据。</li></ol><p>综上所述，OkHttp和Retrofit在Android网络开发中都有着各自的优势。通常情况下，可以使用OkHttp作为底层网络库，而Retrofit作为对OkHttp的高级封装，用于简化网络请求的创建和调用。这样可以既享受OkHttp的性能和灵活性，又能够通过Retrofit简化网络请求的编写和维护</p><h2 id="14-SharedPreferences"><a href="#14-SharedPreferences" class="headerlink" title="14. SharedPreferences"></a>14. SharedPreferences</h2><p>以键值对的形式存储和检索原始数据类型（如整数、浮点数、布尔值和字符串）。它提供了一种简单的方式来保存特定于应用程序或在应用程序之间共享的少量持久数据。</p><ol><li><p><strong>创建或访问 SharedPreferences</strong>：您可以使用 <code>getSharedPreferences()</code> 方法获取 SharedPreferences 的实例，需要提供一个偏好文件的名称和模式（通常如果数据只能被您的应用程序访问，则使用 <code>MODE_PRIVATE</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sharedPreferences = getSharedPreferences(&quot;my_prefs&quot;, Context.MODE_PRIVATE);</span><br></pre></td></tr></table></figure></li><li><p><strong>编辑 SharedPreferences</strong>：要修改偏好设置，您可以使用 <code>edit()</code> 方法获取一个 SharedPreferences.Editor 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences.Editor editor = sharedPreferences.edit();</span><br></pre></td></tr></table></figure></li><li><p><strong>添加数据</strong>：然后，您可以使用 <code>putInt()</code>、<code>putString()</code>、<code>putBoolean()</code> 等方法将数据添加到编辑器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">editor.putInt(&quot;score&quot;, 100);</span><br><span class="line">editor.putString(&quot;username&quot;, &quot;JohnDoe&quot;);</span><br><span class="line">editor.putBoolean(&quot;loggedIn&quot;, true);</span><br></pre></td></tr></table></figure></li><li><p><strong>提交更改</strong>：完成更改后，需要提交以将数据持久化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editor.apply();</span><br></pre></td></tr></table></figure></li><li><p><strong>检索数据</strong>：要从 SharedPreferences 中检索数据，您可以使用 <code>getInt()</code>、<code>getString()</code>、<code>getBoolean()</code> 等方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int score = sharedPreferences.getInt(&quot;score&quot;, 0); // 如果找不到 &quot;score&quot;，默认值为 0</span><br><span class="line">String username = sharedPreferences.getString(&quot;username&quot;, &quot;&quot;);</span><br><span class="line">boolean loggedIn = sharedPreferences.getBoolean(&quot;loggedIn&quot;, false);</span><br></pre></td></tr></table></figure><p>SharedPreferences 常用于存储用户偏好、设置和其他需要在应用程序重新启动时持久化的轻量级数据。但是，需要注意的是，SharedPreferences 不应用于存储大量数据或敏感信息，因为它不是加密的，并且很容易被设备上的其他应用程序访问。对于安全或大规模数据存储，应考虑其他选项，如 SQLite 数据库或加密文件。</p><h3 id="commit-和apply-区别"><a href="#commit-和apply-区别" class="headerlink" title="commit()和apply()区别"></a>commit()和apply()区别</h3><ol><li>**commit()**：<ul><li><code>commit()</code> 方法是同步的，即它会立即将数据写入磁盘并返回写入结果（成功或失败）。因此，在调用 <code>commit()</code> 后，会阻塞调用线程直到数据写入完成。</li><li>由于是同步操作，如果数据量较大或者磁盘IO速度较慢，可能会导致UI线程阻塞，从而影响用户体验。</li></ul></li><li>**apply()**：<ul><li><code>apply()</code> 方法是异步的，它会将数据写入内存，然后在合适的时机（通常是在主线程空闲时）异步将数据写入磁盘，而不会阻塞调用线程。</li><li>由于是异步操作，<code>apply()</code> 方法不会立即返回写入结果，因此无法知道数据是否成功写入。这意味着，即使写入失败也不会收到通知。</li></ul></li></ol></li></ol><h2 id="15-volatile-关键字的作用和原理"><a href="#15-volatile-关键字的作用和原理" class="headerlink" title="15.volatile 关键字的作用和原理"></a>15.volatile 关键字的作用和原理</h2><ul><li><p>禁止了指令重排（指令重排是指：为了提高性能，编译器和和处理器通常会对指令进行指令重排序）</p></li><li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这个新值对其他线程是立即可见的</p><ul><li>这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取</li></ul></li><li><p><strong>不保证原子性</strong></p></li><li><p>原理：volatile的原理是在生成的汇编代码中多了一个lock前缀指令，这个前缀指令相当于一个内存屏障，这个内存屏障有3个作用：</p><ul><li>确保指令重排的时候不会把屏障后的指令排在屏障前，确保不会把屏障前的指令排在屏障后。</li><li>将当前处理器缓存行的数据写回到系统内存</li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存失效</li></ul></li></ul><h2 id="16-synchronized-关键字的作用"><a href="#16-synchronized-关键字的作用" class="headerlink" title="16. synchronized 关键字的作用"></a>16. synchronized 关键字的作用</h2><ul><li>修饰实例方法：作用于<strong>当前对象实例</strong>加锁，进入同步代码前要获得当前对象实例的锁</li><li>修饰静态方法：也就是给当前类（即<strong>XXX.class</strong>对象）加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized  方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</li><li>修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</li><li>synchronized <strong>可重入性</strong>（当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功）</li></ul><h2 id="17-String、StringBuffer、StringBuilder-的区别"><a href="#17-String、StringBuffer、StringBuilder-的区别" class="headerlink" title="17. String、StringBuffer、StringBuilder 的区别"></a>17. String、StringBuffer、StringBuilder 的区别</h2><ul><li>String：值是不可变的，这就导致每次对String的操作都会产生新的String对象，效率低下且浪费内存</li><li>StringBuffer：值可变且线程安全</li><li>StringBuilder：值可变但线程不安全，速度较StringBuffer更快</li><li>使用<code>synchronized</code>关键字来保护它们的操作，以确保在多线程环境中只有一个线程能够访问它们的方法</li></ul><h2 id="18-单例模式"><a href="#18-单例模式" class="headerlink" title="18. 单例模式"></a>18. 单例模式</h2><ul><li><h5 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h5 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h5 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h5></li></ul><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance &#x3D;&#x3D; null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if (instance==null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance==null)&#123;</span><br><span class="line">                    instance=new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    public void whateverMethod() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-ANR发生的原因及其解决办法"><a href="#19-ANR发生的原因及其解决办法" class="headerlink" title="19. ANR发生的原因及其解决办法"></a>19. ANR发生的原因及其解决办法</h2><p>ANR的全称是application not responding，是指应用程序未响应，Android系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成ANR。一般地，这时往往会弹出一个提示框，告知用户当前xxx未响应，用户可选择继续等待或者Force Close。</p><p>首先ANR的发生是有条件限制的，分为以下三点：</p><ul><li>只有主线程才会产生ANR，主线程就是UI线程；</li><li>必须发生某些输入事件或特定操作，比如按键或触屏等输入事件，在BroadcastReceiver或Service的各个生命周期调用函数；</li><li>上述事件响应超时，不同的context规定的上限时间不同<ol><li>主线程对输入事件5秒内没有处理完毕</li><li>主线程在执行BroadcastReceiver的onReceive()函数时10秒内没有处理完毕</li><li>主线程在前台Service的各个生命周期函数时20秒内没有处理完毕（后台Service 200s）</li></ol></li></ul><p>那么导致ANR的根本原因是什么呢？简单的总结有以下两点：</p><ul><li>主线程执行了<strong>耗时操作</strong>，比如数据库操作或网络编程，I&#x2F;O操作</li><li>其他进程（就是其他程序）占用CPU导致本进程<strong>得不到CPU时间片</strong>，比如其他进程的频繁读写操作可能会导致这个问题</li></ul><p>那么如何避免ANR的发生呢或者说ANR的解决办法是什么呢？</p><ul><li>避免在主线程执行耗时操作，所有耗时操作应新开一个子线程完成，然后再在主线程更新UI</li><li>BroadcastReceiver要执行耗时操作时应启动一个service，将耗时操作交给service来完成</li><li>避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广播时需要向用户展示什么，你应该使用Notification Manager来实现</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节一面面经</title>
      <link href="/2024/03/20/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/03/20/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h3><h3 id="2-询问你一些简历上的基本信息"><a href="#2-询问你一些简历上的基本信息" class="headerlink" title="2.询问你一些简历上的基本信息"></a>2.询问你一些简历上的基本信息</h3><h3 id="3-开始拷打提问"><a href="#3-开始拷打提问" class="headerlink" title="3.开始拷打提问"></a>3.开始拷打提问</h3><h4 id="1-Android的四大基本组件：Activity-Service-Content-Provider-Broadcast-Receive"><a href="#1-Android的四大基本组件：Activity-Service-Content-Provider-Broadcast-Receive" class="headerlink" title="(1) Android的四大基本组件：Activity,Service,Content Provider,Broadcast Receive"></a>(1) Android的四大基本组件：Activity,Service,Content Provider,Broadcast Receive</h4><h4 id="2-Activity的生命周期：onCreate-onRestart-onStart-onResume-onPause-onStop-onDestroy"><a href="#2-Activity的生命周期：onCreate-onRestart-onStart-onResume-onPause-onStop-onDestroy" class="headerlink" title="(2) Activity的生命周期：onCreate,onRestart,onStart,onResume,onPause,onStop,onDestroy"></a>(2) Activity的生命周期：onCreate,onRestart,onStart,onResume,onPause,onStop,onDestroy</h4><h4 id="3-view的测量和布局"><a href="#3-view的测量和布局" class="headerlink" title="(3) view的测量和布局"></a>(3) view的测量和布局</h4><h4 id="4-ANR是什么"><a href="#4-ANR是什么" class="headerlink" title="(4) ANR是什么:"></a>(4) ANR是什么:</h4><p>​ANR的全称是application not responding，是指应用程序未响应，Android系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成ANR。一般地，这时往往会弹出一个提示框，告知用户当前xxx未响应，用户可选择继续等待或者Force Close。</p><p>​首先ANR的发生是有条件限制的，分为以下三点：</p><ul><li>只有主线程才会产生ANR，主线程就是UI线程；</li><li>必须发生某些输入事件或特定操作，比如按键或触屏等输入事件，在BroadcastReceiver或Service的各个生命周期调用函数；</li><li>上述事件响应超时，不同的context规定的上限时间不同</li></ul><ol><li>主线程对输入事件5秒内没有处理完毕</li><li>主线程在执行BroadcastReceiver的onReceive()函数时10秒内没有处理完毕</li><li>主线程在前台Service的各个生命周期函数时20秒内没有处理完毕（后台Service 200s）</li></ol><h4 id="5）Java关键字sychronied"><a href="#5）Java关键字sychronied" class="headerlink" title="(5）Java关键字sychronied"></a>(5）Java关键字sychronied</h4><p>​sychronied是Java中并发编程的重要关键字之一。在并发编程中synchronized一直是解决线程安全问题，它可以保证原子性，可见性，以及有序性。</p><p>​<strong>原子性</strong>：原子是构成物质的基本单位，所以原子的意思代表着—“不可分”。由不可分可知，具有原子性的操作也就是拒绝线程调度器中断。</p><p>​<strong>可见性</strong>：一个线程对共享变量的修改，另一个线程能够立刻看到，称为可见性。</p><p>​<strong>有序性</strong>：程序按照代码的先后顺序执行。编译器为了优化性能，有时会改变程序中语句的顺序，但是不会影响最终的结果。有序性经典的例子就是利用DCL双重检查创建单例对象。</p><p>synchronized可以修饰方法，也能够使用<code>synchronized(obj)&#123;&#125;</code>定义同步代码块。</p><ul><li><p>修饰方法：</p></li><li><ol><li>实例方法，作用于当前实例加锁，进入方法前需要获取当前实例的锁;</li><li>静态方法，作用于当前类对象加锁，进入方法前需要获取当前类对象的锁;</li></ol></li><li><p>修饰代码块，指定加锁对象，对给定对象加锁，进入代码块前要获得给定对象的锁。</p></li></ul><p>使用sychronied修饰普通方法和静态方法，其实也等价于<code>synchronized(this)&#123;&#125;</code>与<code>synchronized(class)&#123;&#125;</code>。</p><h4 id="6-Java关键字volatile"><a href="#6-Java关键字volatile" class="headerlink" title="(6)   Java关键字volatile"></a>(6)   Java关键字volatile</h4><p>​volatile是java提供的可以声明在成员属性前的一个关键字。在声明中包含此关键字的作用有：</p><h5 id="保证内存可见性"><a href="#保证内存可见性" class="headerlink" title="保证内存可见性"></a>保证内存可见性</h5><p>​可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。</p><p>​当对非volatile变量进行读写的时候，每个线程先从主内存拷贝变量到CPU缓存中，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。</p><p>​volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，保证了每次读写变量都从主内存中读，跳过CPU cache这一步。当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。</p><h5 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h5><p>​指令重排序是JVM为了优化指令、提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。指令重排序包括编译器重排序和运行时重排序。</p><p>​latile变量禁止指令重排序。针对volatile修饰的变量，在读写操作指令前后会插入内存屏障，指令重排序时不能把后面的指令重排序到内存屏</p><h4 id="7-描述TCP三次握手与四次挥手的过程与意义"><a href="#7-描述TCP三次握手与四次挥手的过程与意义" class="headerlink" title="(7)描述TCP三次握手与四次挥手的过程与意义"></a>(7)描述TCP三次握手与四次挥手的过程与意义</h4><p>​TCP&#x2F;IP协议定义了计算机在网络中如何发送数据、数据格式如何定义、发出消息后在网络中如何寻址找到目标计算机，最后目标计算机又如何检验收到消息的正确性、对数据拆解最后得到消息内容的一套处理标准。</p><p>有了这些标准后生产提供TCP&#x2F;IP服务的软件商家就有了一套统一的规范，只要遵循这个规范去实现自己的软件功能。</p><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p>在进行业务通信前，必须建立好连接，而TCP&#x2F;IP连接的建立需要经过三次握手的过程。其过程如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/8GwA4HUQ6WhOW7LFTicdINApzXHD5KAdmrAObEYcHT0gJ39G7SBez72j7u0nFRNG90EMGgOC7IGuoJxDZVXcQrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ol><li><strong>第一次握手：</strong>建立连接时，客户端发送syn包（syn&#x3D;j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li><strong>第二次握手：</strong>服务器收到syn包，必须确认客户的SYN（ack&#x3D;j+1），同时自己也发送一个SYN包（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li><strong>第三次握手：</strong>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><h5 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h5><p>三次握手的意义在于确定双方都能够完成读写操作。</p><p>第一次握手，客户端发了个连接请求消息到服务端，服务端收到信息后知道自己与客户端是可以连接成功的，但此时客户端并不知道服务端是否已经接收到了它的请求，所以服务端接收到消息后的应答。客户端得到服务端的反馈后，才确定自己与服务端是可以连接上的，这就是第二次握手。而服务端发送出去的消息，要等客户端响应后，才能确定此次连接为有效连接。</p><h5 id="否则假设："><a href="#否则假设：" class="headerlink" title="否则假设："></a><strong>否则假设：</strong></h5><p>客户端发出去的第一个连接请求由于某些原因在网络节点中滞留了导致延迟，直到连接释放的某个时间点才到达服务端，这是一个早已失效的报文，但是此时服务端仍然认为这是客户端的建立连接请求第一次握手，于是服务端回应了客户端，第二次握手。如果没有第三次握手，那么到这里，连接就建立了，但是此时客户端并没有任何数据要发送，会让服务端空等，造成资源浪费。</p><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p>在完成数据交互之后，如果选择关闭连接，以回收资源，则完成四次挥手来进行“和平分手”。过程如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/8GwA4HUQ6WhOW7LFTicdINApzXHD5KAdmb64g8oILKicrQcIpDuGd9SNRXzw8jGcicJcbfYWB0GC9lpSEzoKtLPBQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ol><li><strong>第一次挥手：</strong>主动关闭方发送第一个包，其中FIN标志位为1，发送顺序号seq为X。</li><li><strong>第二次挥手：</strong>被动关闭方收到FIN包后发送第二个包，其中发送顺序号seq为Z，接收顺序号ack为X+1。</li><li><strong>第三次挥手：</strong>被动关闭方再发送第三个包，其中FIN标志位为1，发送顺序号seq为Y，接收顺序号ack为X。</li><li><strong>第四次挥手：</strong>主动关闭方发送第四个包，其中发送顺序号为X，接收顺序号为Y。至此，完成四次挥手。</li></ol><h5 id="为什么断开连接需要四次挥手？"><a href="#为什么断开连接需要四次挥手？" class="headerlink" title="为什么断开连接需要四次挥手？"></a>为什么断开连接需要四次挥手？</h5><p>三次握手是因为建立连接时，ACK和SYN可以放在一个报文里来发送。而关闭连接时，被动关闭方可能还需要发送一些数据后，再发送FIN报文表示同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。因此断开连接需要4次。</p><h4 id="8-TCP和UDP的区别"><a href="#8-TCP和UDP的区别" class="headerlink" title="(8)TCP和UDP的区别"></a>(8)TCP和UDP的区别</h4><p>​TCP是有连接，UDP是无连接的；TCP比UDP传说数据更安全;TCP能够确认数据包是否传给对方，UDP直接发送报文不需要确认是否发送，传输更快。</p><h4 id="9-HTTP和HTTPS是什么，为什么HTTPS比HTTP更安全"><a href="#9-HTTP和HTTPS是什么，为什么HTTPS比HTTP更安全" class="headerlink" title="(9)HTTP和HTTPS是什么，为什么HTTPS比HTTP更安全"></a>(9)HTTP和HTTPS是什么，为什么HTTPS比HTTP更安全</h4><p>​<a href="https://mp.weixin.qq.com/s?__biz=Mzg3ODY2MzU2MQ==&mid=2247490082&idx=2&sn=6084c4330b40aa32a7366661cb5fbc43&chksm=cf1118c4f86691d237db7d5480d179319432cca4cc70536958eedcbba9fef57ead425058e250&token=1436311520&lang=zh_CN#rd">网络编程面试题：谈谈你对Http与Https的关系理解 (qq.com)</a></p><h4 id="10-View的绘制（好像问了，我不会，没记住）"><a href="#10-View的绘制（好像问了，我不会，没记住）" class="headerlink" title="(10)View的绘制（好像问了，我不会，没记住）"></a>(10)View的绘制（好像问了，我不会，没记住）</h4><h4 id="11-一个线程可以有几个Handler，为什么"><a href="#11-一个线程可以有几个Handler，为什么" class="headerlink" title="(11)一个线程可以有几个Handler，为什么"></a>(11)一个线程可以有几个Handler，为什么</h4><h3 id="4-算法题："><a href="#4-算法题：" class="headerlink" title="4.算法题："></a>4.算法题：</h3><p>​二叉树，相当于判断b树是不是a树的子树</p><h3 id="5-面试管询问有没有什么想问的。"><a href="#5-面试管询问有没有什么想问的。" class="headerlink" title="5.面试管询问有没有什么想问的。"></a>5.面试管询问有没有什么想问的。</h3><p><strong>有一些问题可能没记住，忘了录音</strong></p><p>Android面试资料：<a href="https://juejin.cn/post/7267737437953720359">【建议收藏】106道Android核心面试题及答案汇总（总结最全面的面试题） - 掘金 (juejin.cn)</a></p><p><a href="https://github.com/MartinLiuMingZhi/Notes">MartinLiuMingZhi&#x2F;Notes: Java和Android面试八股文 (github.com) </a>（能帮忙star一下吗）</p><p><a href="https://martinliumingzhi.github.io/">Hello World - 愿世界更美好 (martinliumingzhi.github.io)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin常见面试知识点</title>
      <link href="/2024/03/19/Kotlin%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2024/03/19/Kotlin%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="一-Kotlin-与-Java-对比"><a href="#一-Kotlin-与-Java-对比" class="headerlink" title="一.Kotlin 与 Java 对比"></a>一.Kotlin 与 Java 对比</h3><p>Kotlin 和 Java 都是针对 JVM 的编程语言。它们有一些相似之处，比如都支持面向对象编程、静态类型和垃圾回收等。但是 Kotlin 和 Java 也有很多不同之处。以下是一些 Kotlin 和 Java 的比较：</p><ol><li>代码量：Kotlin 比 Java 代码量少很多。Kotlin 通过使用更简洁的语法和函数式编程的概念来简化 Java 代码，以减少代码的复杂性。</li><li>空指针安全：Kotlin 通过引入空指针安全机制来避免空指针异常，而 Java 中需要手动检查 null 值。</li><li>扩展函数：Kotlin 中有一个强大的功能叫做扩展函数，它允许用户将一个已存在的类进行扩展。</li><li>函数式编程概念：Kotlin 支持更多的函数式编程概念，比如 lambda 表达式、高阶函数和尾递归等。</li><li>数据类：Kotlin 中引入了数据类，它允许程序员快速创建简单的数据类。相比之下，Java 需要编写大量的样板代码。</li></ol><p>总的来说，Kotlin 相对于 Java 拥有更简洁的语法，更少的瑕疵，更多的功能和更高的生产效率，但是 Java 相对于 Kotlin 拥有更成熟的生态体系，更广泛的支持和更好的跨平台支持。</p><h3 id="Kotlin-常见关键字"><a href="#Kotlin-常见关键字" class="headerlink" title="Kotlin 常见关键字"></a>Kotlin 常见关键字</h3><p>Kotlin 作为一种独立的编程语言，有一些 Java 中没有的关键字，以下是 Kotlin 特有的一些关键字：</p><ol><li>companion：伴生对象，可以在类内部定义一个对象，用于实现静态方法和属性。</li><li>data：数据类，用于快速创建一个用于存储数据的类。</li><li>by：委托，可以在一个对象中使用另一个对象的属性或方法。</li><li>reified：具体化，用于解决 Java 泛型擦除问题。</li><li>inline：内联，用于在编译时将函数代码插入到调用处，提高性能。</li><li>non-local return：非局部返回，可以在嵌套函数中使用 return 关键字返回到外部函数。</li><li>tailrec：尾递归，用于将递归函数改为尾递归函数，提高性能。</li><li>suspend 和 coroutine：协程，Kotlin 支持协程编程，可以使用 suspend 关键字定义挂起函数，使用 coroutine 构建异步和并发程序。</li></ol><p>这些关键字提供了 Kotlin 编程中一些独特的语法异构，使得程序员可以更轻松地编写高效、可读性优秀的代码。</p><h3 id="Kotlin-常见内置函数"><a href="#Kotlin-常见内置函数" class="headerlink" title="Kotlin 常见内置函数"></a>Kotlin 常见内置函数</h3><ol><li>let：作用于某个对象，让其调用一个函数，并返回 Lambda 表达式的结果。let 函数可以避免在调用 Lambda 表达式时产生多余的变量名，提高了代码可读性。</li><li>apply：作用于某个对象，将对象本身作为接收器（this）返回，可以连续进行多次调用，非常适合链式调用代码块的场景。</li><li>with：非扩展函数，接受一个对象和一个 Lambda 表达式，可以让您在将对象本身作为参数传递的情况下调用 Lambda 表达式。with 函数允许编写更紧凑的代码，特别是当您需要访问一个对象的属性时。</li><li>run：类似于 let 函数，但是只能作用于可空对象。如果对象不为空，run 函数会让对象调用 Lambda 表达式并返回其结果；如果对象为空，run 函数返回 null。</li><li>also：类似于 let 函数，但是返回的值是指定的接收器对象，而不是 Lambda 表达式的结果。可以用于在对象的生命周期内执行额外的操作。</li><li>takeIf：接受一个谓词（Lambda 表达式），并返回任何满足该谓词的对象，否则返回 null。</li><li>takeUnless：与 takeIf 函数相反，如果对象不满足指定的谓词，则返回对象本身，否则返回 null。</li><li>when：作为表达式或语句，类似于 Java 中的 switch 语句，可以匹配多个条件或者值，并执行与条件&#x2F;值对应的代码块。</li></ol><p>这些内置函数属于 Kotlin 标准库的一部分，使得 Kotlin 代码更加简洁、易读、易于维护，特别适用于链式调用或需要多次对某个对象执行某个操作的场景。</p><h3 id="Kotlin-与-RxJava"><a href="#Kotlin-与-RxJava" class="headerlink" title="Kotlin 与 RxJava"></a>Kotlin 与 RxJava</h3><p>Kotlin是一种现代的编程语言，它对函数式编程和响应式编程提供了很好的支持。RxJava也是一种非常流行的响应式编程库。虽然Kotlin本身没有RxJava那么强大，但它提供了一些工具和语言功能来简化异步编程和响应式编程。下面是一些使用Kotlin替代RxJava的技术：</p><ol><li>协程：Kotlin提供了一种名为协程的轻量级线程，可以简化异步编程。协程使用类似于JavaScript的async&#x2F;await语法，允许您轻松地编写异步代码而无需编写回调或使用RxJava。</li><li>Flow：Kotlin的流是一种响应式编程的替代方案。它提供了与RxJava的Observable类似的流式API，但它是基于协程的，并且更容易与Kotlin集成。</li><li>LiveData：LiveData是一种Kotlin Android架构组件，它提供了类似于RxJava的观察者模式。LiveData可以让您轻松地观察数据变化，同时避免RxJava的一些复杂性和性能问题。</li></ol><p>总之，Kotlin提供了许多替代RxJava的工具和功能，从而使异步编程和响应式编程更加简单和直观。</p><h3 id="Kotlin-协程"><a href="#Kotlin-协程" class="headerlink" title="Kotlin 协程"></a>Kotlin 协程</h3><p>以下是一些与Kotlin协程相关的面试题和答案：</p><ol><li>什么是Kotlin协程？</li></ol><p>答：Kotlin协程是一种轻量级的线程，它使用协作式调度来实现并发。与传统的线程不同，协程可以自由地挂起和恢复。它们使并发代码更加轻松和直观，并且可以避免一些常见的并发问题。</p><ol start="2"><li>Kotlin协程的优点是什么？</li></ol><p>答：Kotlin协程的优点包括：</p><ul><li>简单易用：协程使异步代码更加轻松和直观，而无需编写复杂的回调或使用RxJava。</li><li>轻量级：协程使用协作式调度，因此它们比传统线程更加轻量级。</li><li>避免共享状态问题：协程通过将计算任务拆分为许多小的、非共享的组件来避免共享状态问题。</li><li>更好的性能：因为协程是轻量级的，它们的创建和销毁所需的开销更小，因此具有更好的性能。</li></ul><ol start="3"><li>Kotlin协程中的“挂起”意味着什么？</li></ol><p>答：在Kotlin协程中，挂起是指暂停协程的执行，直到某些条件满足。在挂起期间，协程不会占用线程，并且可以由另一个协程或线程执行。协程通常在遇到I&#x2F;O操作或长时间运行的计算时挂起。</p><ol start="4"><li>如何在Kotlin中创建协程？</li></ol><p>答：在Kotlin中，可以使用launch、async和runBlocking等函数来创建协程。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 使用launch创建协程</span><br><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    // 协程执行的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用async创建协程</span><br><span class="line">val deferred = GlobalScope.async &#123;</span><br><span class="line">    // 协程执行的代码并返回结果</span><br><span class="line">    42</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用runBlocking创建协程</span><br><span class="line">runBlocking &#123;</span><br><span class="line">    // 协程执行的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li></li><li>Kotlin中的“协程作用域”是什么？</li></ol><p>答：协程作用域是一种可以帮助协程被正确地取消和清理的机制。它是由Kotlin提供的一个结构，可以创建和管理多个相关联的协程。协程作用域可以确保在其范围内创建的所有协程都被正确地取消，并且可以管理这些协程的执行顺序。</p><ol start="6"><li>Kotlin协程中的“挂起函数”是什么？</li></ol><p>答：挂起函数是指可以在协程中使用的特殊函数，它们可以在执行过程中暂停协程的执行，直到某些条件满足。通常，挂起函数通过使用“挂起标记”（<code>suspend</code>）来定义。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">suspend fun getUser(id: Int): User &#123;</span><br><span class="line">    // 从远程服务器获取用户数据</span><br><span class="line">    return user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>如何处理Kotlin协程中的异常？</li></ol><p>答：在Kotlin协程中，可以使用<code>try/catch</code>语句来处理异常。如果协程中的异常未被捕获，它将传播到协程的上层。可以使用<code>CoroutineExceptionHandler</code>在协程中设置一个全局异常处理程序。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val handler = CoroutineExceptionHandler &#123; _, exception -&gt;</span><br><span class="line">    // 处理异常</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GlobalScope.launch(handler) &#123;</span><br><span class="line">    // 协程执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kotlin-泛型-逆变-协变"><a href="#Kotlin-泛型-逆变-协变" class="headerlink" title="Kotlin 泛型-逆变&#x2F;协变"></a>Kotlin 泛型-逆变&#x2F;协变</h3><p>Kotlin中的泛型支持协变和逆变。接下来分别对它们进行介绍：</p><ol><li>协变（Covariant）</li></ol><p>协变意味着可以使用子类型作为父类型的替代。在Kotlin中，为了支持协变，我们可以将<code>out</code>修饰符添加到泛型参数上。例如，让我们看一个用于生产者的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Producer&lt;out T&gt; &#123;</span><br><span class="line">    fun produce(): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口可以使用<code>out</code>修饰符，表示这是一个生产者，它只会产生类型<code>T</code>的值，而不会对其进行任何更改。因此，我们可以将子类型作为父类型的替代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class AnimalProducer : Producer&lt;Animal&gt; &#123;</span><br><span class="line">    override fun produce(): Animal &#123;</span><br><span class="line">        return Animal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DogProducer : Producer&lt;Dog&gt; &#123;</span><br><span class="line">    override fun produce(): Dog &#123;</span><br><span class="line">        return Dog()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>Dog</code>是<code>Animal</code>的子类型，所以我们可以使用<code>DogProducer</code>作为类型为<code>Producer&lt;Animal&gt;</code>的变量的值。因为我们知道我们总是可以期望<code>DogProducer</code>生产类型为<code>Animal</code>的值。</p><ol start="2"><li>逆变（Contravariant）</li></ol><p>逆变意味着可以使用父类型作为子类型的替代。在Kotlin中，为了支持逆变，我们可以将<code>in</code>修饰符添加到泛型参数上。例如，让我们看一个用于消费者的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Consumer&lt;in T&gt; &#123;</span><br><span class="line">    fun consume(item: T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口可以使用<code>in</code>修饰符，表示这是一个消费者，它只接受类型<code>T</code>的值，而不会返回任何值。因此，我们可以将父类型作为子类型的替代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class AnimalConsumer : Consumer&lt;Animal&gt; &#123;</span><br><span class="line">    override fun consume(item: Animal) &#123;</span><br><span class="line">        // 消费Animal类型的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DogConsumer : Consumer&lt;Dog&gt; &#123;</span><br><span class="line">    override fun consume(item: Dog) &#123;</span><br><span class="line">        // 消费Dog类型的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>Animal</code>是<code>Dog</code>的父类型，所以我们可以使用<code>AnimalConsumer</code>作为类型为<code>Consumer&lt;Dog&gt;</code>的变量的值。因为我们知道我们总是可以期望<code>AnimalConsumer</code>会接受类型为<code>Dog</code>的值。</p><p>总之，Kotlin中的协变和逆变提供了更好的类型安全性和代码灵活性。使用它们可以确保类型转换是正确的，并且可以使程序更加健壮和易于维护。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程面试题</title>
      <link href="/2024/03/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/03/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="描述TCP三次握手与四次挥手的过程与意义"><a href="#描述TCP三次握手与四次挥手的过程与意义" class="headerlink" title="描述TCP三次握手与四次挥手的过程与意义"></a>描述TCP三次握手与四次挥手的过程与意义</h1><h3 id="考生如何回答"><a href="#考生如何回答" class="headerlink" title="考生如何回答"></a><strong>考生如何回答</strong></h3><p>TCP&#x2F;IP协议定义了计算机在网络中如何发送数据、数据格式如何定义、发出消息后在网络中如何寻址找到目标计算机，最后目标计算机又如何检验收到消息的正确性、对数据拆解最后得到消息内容的一套处理标准。</p><p>有了这些标准后生产提供TCP&#x2F;IP服务的软件商家就有了一套统一的规范，只要遵循这个规范去实现自己的软件功能。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>在进行业务通信前，必须建立好连接，而TCP&#x2F;IP连接的建立需要经过三次握手的过程。其过程如下图：</p><p><img src="https://image.liumingzhi.cn/file/f1fd954e395cf9bf2a812.png"></p><ol><li><strong>第一次握手：</strong>建立连接时，客户端发送syn包（syn&#x3D;j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li><strong>第二次握手：</strong>服务器收到syn包，必须确认客户的SYN（ack&#x3D;j+1），同时自己也发送一个SYN包（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li><strong>第三次握手：</strong>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><h3 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h3><p>三次握手的意义在于确定双方都能够完成读写操作。</p><p>第一次握手，客户端发了个连接请求消息到服务端，服务端收到信息后知道自己与客户端是可以连接成功的，但此时客户端并不知道服务端是否已经接收到了它的请求，所以服务端接收到消息后的应答。客户端得到服务端的反馈后，才确定自己与服务端是可以连接上的，这就是第二次握手。而服务端发送出去的消息，要等客户端响应后，才能确定此次连接为有效连接。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>在完成数据交互之后，如果选择关闭连接，以回收资源，则完成四次挥手来进行“和平分手”。过程如下图：</p><p><img src="https://image.liumingzhi.cn/file/b9fbf2e79327f9d55ebd5.png"></p><ol><li><strong>第一次挥手：</strong>主动关闭方发送第一个包，其中FIN标志位为1，发送顺序号seq为X。</li><li><strong>第二次挥手：</strong>被动关闭方收到FIN包后发送第二个包，其中发送顺序号seq为Z，接收顺序号ack为X+1。</li><li><strong>第三次挥手：</strong>被动关闭方再发送第三个包，其中FIN标志位为1，发送顺序号seq为Y，接收顺序号ack为X。</li><li><strong>第四次挥手：</strong>主动关闭方发送第四个包，其中发送顺序号为X，接收顺序号为Y。至此，完成四次挥手。</li></ol><h3 id="为什么断开连接需要四次挥手？"><a href="#为什么断开连接需要四次挥手？" class="headerlink" title="为什么断开连接需要四次挥手？"></a>为什么断开连接需要四次挥手？</h3><p>三次握手是因为建立连接时，ACK和SYN可以放在一个报文里来发送。而关闭连接时，被动关闭方可能还需要发送一些数据后，再发送FIN报文表示同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。因此断开连接需要4次。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/18/hello-world/"/>
      <url>/2024/03/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
